{"meta":{"title":"Big Wolf’s Blog","subtitle":null,"description":null,"author":"与狼同行","url":"http://chenmingjia.github.io"},"pages":[{"title":"About","date":"2016-10-18T02:47:25.000Z","updated":"2016-10-18T01:45:44.000Z","comments":true,"path":"about/index.html","permalink":"http://chenmingjia.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-18T02:47:26.000Z","updated":"2016-10-18T01:45:44.000Z","comments":true,"path":"categories/index.html","permalink":"http://chenmingjia.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2016-11-17T07:04:51.000Z","updated":"2016-11-17T07:04:51.000Z","comments":true,"path":"gallery/index.html","permalink":"http://chenmingjia.github.io/gallery/index.html","excerpt":"","text":""},{"title":"links","date":"2016-11-17T06:59:51.000Z","updated":"2016-11-17T06:59:51.000Z","comments":true,"path":"links/index.html","permalink":"http://chenmingjia.github.io/links/index.html","excerpt":"","text":""},{"title":"标签云","date":"2016-11-17T07:23:43.000Z","updated":"2016-11-17T07:23:43.000Z","comments":true,"path":"tags/index.html","permalink":"http://chenmingjia.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[iOS]并发编程录--锁","slug":"unitsquare","date":"2016-11-15T16:00:00.000Z","updated":"2016-11-17T06:54:50.000Z","comments":true,"path":"2016/11/16/unitsquare/","link":"","permalink":"http://chenmingjia.github.io/2016/11/16/unitsquare/","excerpt":"","text":"#一、锁的基本介绍 ###1.1为什么需要锁？？(1)解决资源共享问题我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。 这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。 在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（乱序执行）。(2)并发编程为什么难？什么是重排序？重排序分为两类：编译期重排序和运行期重排序(乱序执行)1234假设x,y初始都为0,请问r1、r2最终为什么会是0？Thread1 ：x=1；r1=y； 123Thread2 ：y=1；r2=x； 这是并发编程非常经典一个问题。在了解乱序执行之前，大多数我们一定会认为答案一定在0,1、1,0、1,1这三者之间。事实上,这题目还肯定存在0，0的结果。我们总是想当然的认为x=1一定会发生在r1=y之前，事实上，编译器会乱序执行，因为它认为在当前线程打乱顺序是无所谓的。但其实它对另外一个线程同时使用的变量来说非常重要。 类似的情况还有很多,现代微处理器的设计使用了数据缓存、指令重叠执行和内存乱序访问。如果没有做好共享数据的同步，很容易出现各种看似诡异的问题。 ###1.2锁的各个性能看到除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的。有消息称，苹果在新系统中已经优化了 pthread_mutex 的性能，所以它看上去和 OSSpinLock 差距并没有那么大了。 上图是常规的锁操作性能测试(iOS7.0SDK，iPhone6模拟器，Yosemite 10.10.5)，垂直方向表示耗时，单位是秒，总耗时越小越好，水平方向表示不同类型锁的锁操作，具体又分为两部分，左边的常规lock操作(比如NSLock)或者读read操作(比如ANReadWriteLock)，右边则是写write操作，图上仅有ANReadWriteLock和ANRecursiveRWLock支持，其它不支持的则默认为0，图上看出，单从性能表现，原子操作是表现最佳的(0.057412秒)，@synchronized则是最耗时的(1.753565秒) (测试代码)正如前文所述，不同方案各有侧重，适用于不用的场景，不能唯性能论高低：原子操作虽然性能很好，但仅限于set/get，比如对列表的插入移除操作需要做同步则无能为力，支持不到，所以适用于一些实例成员变量的读写同步； ##二、互斥锁mutex ###2.1基本概念互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。 除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。 ###2.2实际使用 pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 ###2.3pthread_mutex的实现与NSLock互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。 上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。 另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。 NSLock、NSRecursiveLock是典型的面向对象的锁，即同步锁类，遵循Objective-C的NSLocking协议接口，前者支持tryLock，后者支持递归(可重入)；它的实现非常简单，通过宏，定义了lock方法:123456#define MLOCK \\- (void) lock\\&#123;\\int err = pthread_mutex_lock(&amp;_mutex);\\// 错误处理 ……&#125; NSLock只是在内部封装了一个pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部pthread_mutex互斥锁的类型不同。通过宏定义，可以简化方法的定义。NSLock比pthread_mutex略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 ###2.4性能与使用场景pthread_mutex是pthread经典的基于互斥量机制的同步锁，特性、性能以及稳定各方面都已被大量项目所验证，也是比较推荐作为常规同步锁首选 ###三、自旋锁OSSpinLockiOS/MacOS自有的自旋锁，其特点是线程等待取锁时不进内核，线程因此不挂起，直接保持空转，这使得它的锁操作开销降得很低，OSSpinLock是不支持递归的； ###3.1基本使用123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;OSSpinLockLock(&amp;theLock);sleep(1);NSLog(@&quot;需要线程同步的操作2&quot;);OSSpinLockUnlock(&amp;theLock);&#125;); ###3.2基本原理自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述:12345do &#123; Acquire Lock Critical section // 临界区 Release Lock Reminder section // 不需要锁保护的代码&#125; 在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。 自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下:12345678bool lock = false; // 一开始没有锁上，任何线程都可以申请锁do &#123;while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 lock = true; // 挂上锁，这样别的线程就无法获得锁 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 注释写得很清楚，就不再逐行分析了。可惜这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。 ###3.3原子操作狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。 然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。 这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成1234567bool lock = false; // 一开始没有锁上，任何线程都可以申请锁do &#123;while(test_and_set(&amp;lock); // test_and_set 是一个原子操作Critical section // 临界区lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码&#125; ###3.4致命缺点(1)安全问题，优先级反转(2)如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。 得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段；‘ ###3.1什么是优先级反转？高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。 从中得到的教训是，使用不同优先级听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。 ###为什么其他锁不会发生优先级反转？ #3.6使用场景自旋锁适合短时间的操作，加锁性能最快，但不能使用不同优先级。 ##四、读写锁 ###4.1 ###4.2 ###4.3性能读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响；以pthread_mutex和ANRecursiveRWLock为例，假设mutex的lock耗时为lk，则rw的read lock耗时为2.7lk(从性能测试图表数据得出)，read操作耗时为rd，1000次的多线程接口访问：12mutex总耗时 = 1000*lk + 1000*rdrw总耗时 = 1000*2.7*lk + 1000/c*rd 其中c表示应用的并发数，根据开发文档和技术资料，iOS第二条线程起stack为512KB，而单个应用useable memory size在50MB以内，即c&lt;=100；假设线程数取中值c=50(严格来说，线程数不等于冲突计数，冲突计数很可能会比线程数小得多，线程同步运行不代表就即刻会发生冲突)，当 mutex总耗时 &gt; rw总耗时：1mutex总耗时 &gt; rw总耗时 =》 50*lk + 50*rd &gt; 50*2.7lk + rd =》 49*rd &gt; 85*lk =》 rd &gt; 1.73*lk 可以看出，只要read操作耗时超过锁操作耗时的1.7倍(这其实很容易达到的)，读写锁的性能就会占优势假设线程数c=2(如上述，这里是假设了两个线程之间是竞争了，发生冲突，实际未必)：1mutex总耗时 &gt; rw总耗时 =》 2*lk + 2*rd &gt; 5.4*lk + rd =》 rd &gt; 3.4lk 即使只有两个并发线程，只要read操作耗时超过锁操作耗时的3.4倍，读写锁的性能还会占优势假设线程数c=1：1mutex总耗时 &gt; rw总耗时 =》0 &gt; 1.7lk 这显然不成立，说明当单个线程的时候，rw的性能不可能有优势。这也好理解，这时候的mutex和rw的读操作都相当完全同步，不论是mutex还是rw，性能完全取决于锁操作本身，而rw在锁操作耗时上就不占优势，所以mutex总耗时总是要小于rw总耗时的。 上图是mutex锁和rw锁read操作的耗时测试用例，下图为测试结果，read操作设置为100微秒，mutex锁的总耗时是rw锁的5倍多，read操作的耗时远比锁操作大许多(2k倍)，根据上述恒等式计算可以得出实际的冲突计数c=5 ###五、信号量 ###5.1基本概念 ###5.2基本原理dispatch_semaphore的性能表现出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制，是否适用于常规同步锁有待实践验证。不做推荐信号量dispatch_semaphore_t的实现原理，它最终会调用到sem_wait方法，这个方法在 glibc 中被实现如下:1234567int sem_wait (sem_t *sem) &#123;int *futex = (int *) sem;if (atomic_decrement_if_positive (futex) &gt; 0)return 0;int err = lll_futex_wait (futex, 0);return -1;) 首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在lll_futex_wait函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到SYS_futex这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。 ###5.3缺点在时间较短的操作，没有自旋锁高效，会有上下文切换的成本。 ###5.4优点相对 #六、条件锁 ###6.1基本概念NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。 ###6.2基本使用很多介绍pthread_cond_t的文章都会提到，它需要与互斥锁配合使用:12345678910void consumer () &#123; // 消费者pthread_mutex_lock(&amp;mutex);while (data == NULL) &#123;pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据&#125;// --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓// temp = data;// --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑pthread_mutex_unlock(&amp;mutex);&#125; 自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。 wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。 ###为什么要使用条件变量介绍条件变量的文章非常多，但大多都对一个一个基本问题避而不谈:“为什么要用条件变量？它仅仅是控制了线程的执行顺序，用信号量或者互斥锁能不能模拟出类似效果？”网上的相关资料比较少，我简单说一下个人看法。信号量可以一定程度上替代 condition，但是互斥锁不行。在以上给出的生产者-消费者模式的代码中，pthread_cond_wait方法的本质是锁的转移，消费者放弃锁，然后生产者获得锁，同理，pthread_cond_signal则是一个锁从生产者到消费者转移的过程。如果使用互斥锁，我们需要把代码改成这样:123456789void consumer () &#123; // 消费者pthread_mutex_lock(&amp;mutex);while (data == NULL) &#123;pthread_mutex_unlock(&amp;mutex);pthread_mutex_lock(&amp;another_lock) // 相当于 wait 另一个互斥锁pthread_mutex_lock(&amp;mutex);&#125;pthread_mutex_unlock(&amp;mutex);&#125; 这样做存在的问题在于，在等待 another_lock 之前， 生产者有可能先执行代码， 从而释放了 another_lock。也就是说，我们无法保证释放锁和等待另一个锁这两个操作是原子性的，也就无法保证“先等待、后释放 another_lock” 这个顺序。用信号量则不存在这个问题，因为信号量的等待和唤醒并不需要满足先后顺序，信号量只表示有多少个资源可用，因此不存在上述问题。然而与pthread_cond_wait保证的原子性锁转移相比，使用信号量似乎存在一定风险(暂时没有查到非原子性操作有何不妥)。不过，使用 condition 有一个好处，我们可以调用pthread_cond_broadcast方法通知所有等待中的消费者，这是使用信号量无法实现的。 #七、@synchronized 这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 #综合上述分析与讨论，总结有以下几点原则：1、总的来看，推荐pthread_mutex作为实际项目的首选方案；2、对于耗时较大又易冲突的读操作，可以使用读写锁代替pthread_mutex；3、如果确认仅有set/get的访问操作，可以选用原子操作属性；4、对于性能要求苛刻，可以考虑使用OSSpinLock，需要确保加锁片段的耗时足够小；5、条件锁基本上使用面向对象的NSCondition和NSConditionLock即可；6、@synchronized则适用于低频场景如初始化或者紧急修复使用； #八、锁的第二层含义 一个简单的问题：在存在编译乱序与指令执行乱序的情况下，怎么保证锁所保护的代码片段，不会被提前到加锁之前，或者是放锁之后执行？如果编译器将锁保护下的代码，通过编译优化，放到了加锁之前运行？又如果CPU在执行指令时，将锁保护下的汇编代码，延迟到了放锁之后执行？如下图所示： 如上所示，如果编译器做了它不该做的优化，或者CPU做了其不该做的乱序，那么spinlock保护下的代码片段，同一时刻，一定只有一个线程能够执行的假设被打破了。此时，虽然spinlock仍旧只能有一个线程持有，但是spinlock保护下的代码，被提到了spinlock保护之外执行，spinlock哪怕功能再强大，也不能保护锁之外的代码，提取到spinlock锁之外的代码，能够并发执行。 但是上面的测试说明，spinlock保护下的global_count++操作，在多线程下能够正确执行。也就说明，无论是编译器，还是CPU，并没有不合时宜的做上面的这些优化。而分析其原因，刚好引出了锁（Spinlock、Mutex、RWLock等）的第二层意义：Lock Acquire和Unlock Release。 什么是Lock Acquire，Unlock Release又意味着什么？在此之前，需要先看看什么是Acquire和Release。Acquire和Release语义（Semantics）是程序语言和CPU内存模型（Memory Model）中的一个概念。以下，是截取自Preshing博客《Acquire and Release Semantics》一文中，对Acquire与Release Semantics的定义： Acquire semantics is a property which can only apply to operations which read from shared memory, whether they are read-modify-write operations or plain loads. The operation is then considered a read-acquire. Acquire semantics prevent memory reordering of the read-acquire with any read or write operation which follows it in program order. （注：Acquire语义是一个作用于内存读操作上的特性，此内存读操作即被视为read-acquire。Acquire语义禁止read-acquire之后所有的内存读写操作，被提前到read-acquire操作之前进行。） Release semantics is a property which can only apply to operations which write to shared memory, whether they are read-modify-write operations or plain stores. The operation is then considered a write-release. Release semantics prevent memory reordering of the write-release with any read or write operation which precedes it in program order.（注：Release语义作用于内存写操作之上的特性，此内存写操作即被视为write-release。Release语义禁止write-release之前所有的内存读写操作，被推迟到write-release操作之后进行。） 从Acquire与Release语义的定义可以看出，两个语义对编译器优化、CPU乱序分别做了一个限制条件： Acquire语义限制了编译器优化、CPU乱序，不能将含有Acquire语义的操作之后的代码，提到含有Acquire语义的操作代码之前执行；acquire sematics Release语义限制了编译器优化、CPU乱序，不能将含有Release语义的操作之前的代码，推迟到含有Release语义的操作代码之后执行；release sematics 有了明确的Acquire和Release语义的定义，再回过头来看前面提到的锁的第二层含义：Lock Acquire和Unlock Release。加锁操作自带Acquire语义，解锁操作自带Release语义。将加锁、解锁的两个语义结合起来，就构成了以下的完整的锁的含义图： 锁含义 spinlock，只有带有了Acquire和Release语义，才算是一个真正完整可用的锁——Acquire与Release语义间，构成了一个临界区。获取spinlock后的线程，可以大胆的运行全局变量的读写，而不必担心其他并发线程对于此变量的并发访问。 好消息是，pthread lib所提供的spinlock、mutex，其加锁操作都自带了acquire语义，解锁操作都自带了release语义。因此，哪怕我们在使用的过程中，不知道有这两个语义的存在，也能够正确的使用这些锁。但是，读者需要实现自己的spinlock、mutex（注：实际情况下，确实有这个必要，数据库系统如Oracle/PostgreSQL/InnoDB，都有自己实现的Spinlock、Mutex等），那么对于锁的了解，到这个层次，是必不可少的。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://chenmingjia.github.io/tags/iOS/"},{"name":"并发编程","slug":"并发编程","permalink":"http://chenmingjia.github.io/tags/并发编程/"},{"name":"梳理篇","slug":"梳理篇","permalink":"http://chenmingjia.github.io/tags/梳理篇/"}],"keywords":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}]},{"title":"[iOS]并发编程--GCD(上)","slug":"unitsquare","date":"2016-11-14T16:00:00.000Z","updated":"2016-11-17T11:35:42.000Z","comments":true,"path":"2016/11/15/unitsquare/","link":"","permalink":"http://chenmingjia.github.io/2016/11/15/unitsquare/","excerpt":"","text":"##一、Dispatch Queue ###1.1为什么要有线程池的概念GCD 队列的内部使用的是线程。GCD 管理这些线程池,暴露 API，提供一层抽象层级。一般来说使用GCD,你只需考虑队列和功能点（提交给队列的 block）。 GCD即便使用了线程池，也并非完全也可以脱离线程的概念，当一个完整APP里纵横n个异步线程时，GCD的线程池仍然会出现疯狂创造线程，影响主线程 队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程做并发时，很可能会变成分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当处理功能点时，可能会调用一些函数作为功能的一部分,写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在成了64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。 GCD最佳线程数为当前内核数,我电脑是8核Macbook Pro,即最佳线程数为8，使用GCD最多创建68个线程。 GCD 通过创建所谓的线程池来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题： 如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。 ###1.2 Queue的模型演示首先GCD会有一个分发队列(Dispatch Queue),它允许我们去提交一些工作任务,以闭包的形式()-&gt;(),当分发开始执行时,它会建立额外的线程和服务来执行任务,当队列中的任务被分发完毕,它也会负责回收线程。 我们可以建立自己的线程,可以在该线程中跑runLoop,比如说我们的主线程,就是很特殊的,它有它自己的Main Runloop和主队列(Main Queue)。 ###1.3 实际使用123456let queue = DispatchQueue(label: &quot;queueLabel&quot;, //标签qos: .default, //优先级attributes: .concurrent, //并发还是串行autoreleaseFrequency: .inherit, //释放频率target: nil) //目标队列 使用总结如下:优先级：如果没有特殊性能要求，应该总是用.default！！！,避免优先级反转,高手可以使用其他优先级,切记要规避自旋锁！释放频率:inherit，workItem，never。作为Swift3出现的新属性,这个属性应该总是为.workItem！！！。历史原因:释放频率是为了弥补以前GCD当线程不活跃时,会在开发者无法掌控的时间自动往自动释放池释放对象,而这种无法掌握的事情缺点很多,实际开发中，开发者要么自己手动创建释放池释放调度对象，要么出现内存悬挂。于是Apple使用新的workitem来解决手动释放的问题,其实2个选项为了适配旧的代码,never是GCD不会为你管理自动释放池,可能为一些特殊项目使用,inherit是旧的模式，适配旧代码本段释放频率参考:http://stackoverflow.com/questions/38884418/autoreleasefrequency-on-dispatchqueue-in-swift-3-beta-5 ###1.4原理剖析以 dispatch_queue_create 的源码为例:123456789101112131415161718dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) &#123;// 省略 label 相关的操作dispatch_queue_t dq;dq = _dispatch_alloc(DISPATCH_VTABLE(queue),sizeof(struct dispatch_queue_s) - DISPATCH_QUEUE_MIN_LABEL_SIZE -DISPATCH_QUEUE_CACHELINE_PAD + label_len + 1);_dispatch_queue_init(dq);if (fastpath(!attr)) &#123;return dq;&#125;if (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;dq-&gt;dq_width = UINT32_MAX;dq-&gt;do_targetq = _dispatch_get_root_queue(0, false);&#125; else &#123;dispatch_debug_assert(!attr, &quot;Invalid attribute&quot;);&#125;return dq;&#125; 其中 fastpath 和 slowpath 是基于if判断的指令优化,第一个 if 判断中，苹果认为串行队列，或者 NULL 参数更常见，因此 !attr 的值很有可能不为 0，这与上文的结论一致。 第二个判断中，参数几乎有只可能是 DISPATCH_QUEUE_CONCURRENT ，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断机会不会为 0，依然与 fastpath 的作用一致。 _dispatch_get_root_queue 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载(overcommit)。 这 8 个全局队列的序列号是 4-11，序列号为 1 的队列是主队列，2 是 manager 队列，用来管理 GCD 内部的任务(比如下文介绍的定时器)，3 这个序列号暂时没有使用。队列 的 dq_width 被设置为 UINT32_MAX，表示这些队列不限制并发数。串行队列的 dq_width默认为1. 而最后target_queue是GCD一个非常重要的概念,向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个不支持 overcommit 的全局队列，全局队列的底层则是一个线程池。上图其实有11个全局队列。没有完整。 ##二、异步执行Asynchronous Execution ###2.1.闭包或block派发任务闭包或block会被转化为dispatch_continuation_t12345dispatch_continuation_t dc = fastpath(_dispatch_continuation_alloc_cacheonly());dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);dc-&gt;dc_func = func;dc-&gt;dc_ctxt = context;_dispatch_queue_push(dq, dc); 可以理解为一个队列任务块，然后push到队列中——这里的队列是调用async的队列，如果是内部的任务，提交给_dispatch_mgr_q内部队列。12345678dispatch_async(dispatch_queue_t dq, void (^work)(void))&#123;dispatch_continuation_t dc = _dispatch_continuation_alloc();uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT;_dispatch_continuation_init(dc, dq, work, 0, 0, dc_flags);_dispatch_continuation_async(dq, dc);&#125; 可以看到闭包被封装为_dispatch_continuation，然后进行下一个函数。 ###2.2调用过程12345678910111213void dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;dispatch_continuation_t dc;if (dq-&gt;dq_width == 1) &#123;return dispatch_barrier_async_f(dq, ctxt, func);&#125;dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT;dc-&gt;dc_func = func;dc-&gt;dc_ctxt = ctxt;if (dq-&gt;do_targetq) &#123;return _dispatch_async_f2(dq, dc);&#125;_dispatch_queue_push(dq, dc);&#125; 可见如果是串行队列 (dq_width = 1)，会调用 dispatch_barrier_async_f 函数处理，这个后文会有介绍。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下:1234567_dispatch_queue_push└──_dispatch_trace_queue_push└──_dispatch_queue_push└──_dispatch_queue_push_slow└──_dispatch_queue_push_list_slow2└──_dispatch_wakeup└──dx_probe 队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法。然后就是_dispatch_queue_wakeup_global-&gt;调用pthread-&gt;_dispatch_worker_thread 回调-&gt;执行任务-&gt;invoke 2.3 ##三、同步执行Synchronous Execution1234567891011121314static void _dispatch_sync_f_slow(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;_dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();struct dispatch_sync_slow_s &#123;DISPATCH_CONTINUATION_HEADER(sync_slow);&#125; dss = &#123;.do_vtable = (void*)DISPATCH_OBJ_SYNC_SLOW_BIT,.dc_ctxt = (void*)sema,&#125;;_dispatch_queue_push(dq, (void *)&amp;dss);_dispatch_thread_semaphore_wait(sema);_dispatch_put_thread_semaphore(sema);// ...&#125; ##四、派发源Dispatch Sources ###4.1原理剖析下图为dispatch_source_create这个API的代码,如何创建派发源的过程1234567ds = _dispatch_alloc(DISPATCH_VTABLE(source),sizeof(struct dispatch_source_s));_dispatch_queue_init((dispatch_queue_t)ds);ds-&gt;dq_label = &quot;source&quot;;ds-&gt;do_ref_cnt++; // the reference the manager queue holdsds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;ds-&gt;do_targetq = &amp;_dispatch_mgr_q; 从这段源码中我们可以知道：1. 猜想do是dispatchObject,是GCD的最基础类,虽然C语言中没有面向对象编程中的继承这个概念，但只要将dispatch_object_t结构体放在内存布局的开始处（作为“基类”），则实现了继承的概念2. ds-&gt;do_ref_cnt++即是dispatchSource的基类部分的引用计数+13. _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写,证明了即便 dispatch_source_create这个API不传入queue参数,也有root queue来分发 ###4.2GCD Timer并非没有弱点于定时器的有效工作，有两个关键环节，一个是mgr queue，另一个是root queue。可以看到mgr queue只是负责事件监听和分发，可以理解是很轻量级的、不应该也不允许存在失效的；而root queue则负责从线程池分配线程执行任务，线程池的大小目前来看是255，并且有高低优先级之分。 我们创建的GCD Timer的优先级是继承自它的targetq的，而我们正常创建的queue所对应的root queue优先级是default，所以说如果存在大量高优先级的任务派发，或者255个线程都卡住了，那么GCD Timer是会被影响到的。 ##4.3、com.apple.libdispatch-manager作为iOS开发，我们对com.apple.libdispatch-manager这个字符串应该很熟悉，比如在crash日志中看过，也会在断点调试时遇到——它基本都是紧随在主线程之后。123456789101112131415161718static const struct dispatch_queue_vtable_s _dispatch_queue_mgr_vtable = &#123;.do_type = DISPATCH_QUEUE_MGR_TYPE,.do_kind = &quot;mgr-queue&quot;,.do_invoke = _dispatch_mgr_invoke,.do_debug = dispatch_queue_debug,.do_probe = _dispatch_mgr_wakeup,&#125;;struct dispatch_queue_s _dispatch_mgr_q = &#123;.do_vtable = &amp;_dispatch_queue_mgr_vtable,.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,.do_targetq = &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_COUNT - 1],.dq_label = &quot;com.apple.libdispatch-manager&quot;,.dq_width = 1,.dq_serialnum = 2,&#125;; 我们发现，就连_dispatch_mgr_q都有它对应的do_targetq，从命名上来看，可以初步推断_dispatch_mgr_q要做的事情最终都会丢到它的targetq上来完成。_dispatch_root_queues[DISPATCH_ROOT_QUEUE_COUNT - 1]即是序号3队列,用于内部任务的队列。比如将定时器相关信息以及下一步要调用的方法封装成dispatch_continuation_t结构放到队列_dispatch_mgr_q中。那么，_dispatch_mgr_q是做什么的呢？可以先简单直接地看看它通常在做什么： 可以看到，它通常都是没事干等事来。先来看看它怎么处于等事干的状态，也就是它怎么被创建出来并初始化完成的。 我们从上图调用栈可以看到线程入口是_dispatch_mgr_thread，它是作为_dispatch_mgr_q的.do_invoke的：do_invoke的调用在整个libdispatch中，只有在元素出队的时候才会触发。_dispatch_mgr_q从root queue出队时会进入等事干的状态，那么它是什么时候进队的？当我们要push任务块进入队列时会唤醒_dispatch_mgr_q队列并调用其.do_probe成员,_dispatch_mgr_q进行初始化配置进队并wakeup它的targetq。由于它的targetq是root queue，所以就会调用。1.进队调用do_probe，出队调用do_invoke2.顺序是:push任务块-&gt;调用管理队列的do_probe成员-&gt;该成员负责唤醒管理队列并初始化-&gt;管理队列往root队列进队,即调用do_probe-&gt;_dispatch_queue_wakeup_global调用最底层全局线程-&gt;出队do_invoke-&gt;等待事件 ##五、GCD的尽头—线程池// 老版本libdispatch的代码，新版本不同12345678910111213141516171819202122232425262728293031323334static struct dispatch_queue_s _dispatch_root_queues[] = &#123;&#123;.do_vtable = &amp;_dispatch_queue_root_vtable,.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,.do_ctxt = &amp;_dispatch_root_queue_contexts[0],.dq_label = &quot;com.apple.root.low-priority&quot;,.dq_running = 2,.dq_width = UINT32_MAX,.dq_serialnum = 4,&#125;,&#123;// ... 省略部分代码.dq_label = &quot;com.apple.root.low-overcommit-priority&quot;,&#125;,&#123;// ... 省略部分代码.dq_label = &quot;com.apple.root.default-priority&quot;,&#125;,&#123;// ... 省略部分代码.dq_label = &quot;com.apple.root.default-overcommit-priority&quot;,&#125;,&#123;// ... 省略部分代码.dq_label = &quot;com.apple.root.high-priority&quot;,&#125;,&#123;// ... 省略部分代码.dq_label = &quot;com.apple.root.high-overcommit-priority&quot;,&#125;,&#125;; 可以看到，在老版本的libdispatch中，_dispatch_mgr_q是取最高优先级的root queue来作为do_targetq的。而在新版本中，则是有专门为其服务的root queue：1234567891011static struct dispatch_queue_s _dispatch_mgr_root_queue = &#123;.do_vtable = DISPATCH_VTABLE(queue_root),.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,.do_ctxt = &amp;_dispatch_mgr_root_queue_context,.dq_label = &quot;com.apple.root.libdispatch-manager&quot;,.dq_running = 2,.dq_width = DISPATCH_QUEUE_WIDTH_MAX,.dq_serialnum = 3,&#125;;","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://chenmingjia.github.io/tags/iOS/"},{"name":"原理篇","slug":"原理篇","permalink":"http://chenmingjia.github.io/tags/原理篇/"},{"name":"并发编程","slug":"并发编程","permalink":"http://chenmingjia.github.io/tags/并发编程/"},{"name":"GCD","slug":"GCD","permalink":"http://chenmingjia.github.io/tags/GCD/"}],"keywords":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}]},{"title":"[iOS]Instagram/IGListKit实践谈","slug":"unitsquare","date":"2016-11-09T16:00:00.000Z","updated":"2016-11-17T07:03:58.000Z","comments":true,"path":"2016/11/10/unitsquare/","link":"","permalink":"http://chenmingjia.github.io/2016/11/10/unitsquare/","excerpt":"","text":"#简单介绍IGListKit是Instagram推出的新的 UICollectionView 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。github地址：https://github.com/Instagram/IGListKit这个全新的控件一出来，我就赶快投入实践了一把。 先谈一谈我对这个控件的结论:这个框架设计的非常好，完美符合高内聚、低耦合。IGListKit 是一个很典型的使用 Objective-C 开发的，但却是个偏向使用 Swift 语言开发者的一个 UI 组件库。使用过程也面临了一些疑惑，先谈一下使用收获: 它的优势在于flexible，比起原来的 UICollectionView ，在使用上更加灵活，在数据驱动上做的更好。 这个框架在fast上体现的还不够，但不妨碍我们自己进行下一步优化。 #先看看IGListKit的结构 在原来的UICollectionViewController里的写法，我们一定都会实现UICollectionDataSource和UICollectionViewDelegate。不过在IGListKit的实战过程中，你会发现似乎不用在ViewController中实现相关协议，取而代之的是SectionController来实现对应的方法:1234567891011121314class DemoSectionController: IGListSectionController, IGListSectionType&#123;var object: DemoItem?func numberOfItems() -&gt; Int &#123;return 1&#125;func sizeForItem(at index: Int) -&gt; CGSize &#123;return CGSize(width: collectionContext!.containerSize.width, height: 55)&#125;func cellForItem(at index: Int) -&gt; UICollectionViewCell &#123;let cell = collectionContext!.dequeueReusableCell(of: LabelCell.self, for: self, at: index) as! LabelCellcell.label.text = object?.namereturn cell&#125;&#125; 这里直接取了官方的Demo里的其中一个SectionController作为例子。其实 UICollectionDataSource 和 UICollectionViewDelegate 都交给了 Adapter 这个适配器中。我们来看一下 IGAdapter.m 文件中的源码:当我们为适配器绑定collectionView时，调用如下方法123456789- (void)setCollectionView:(IGListCollectionView *)collectionView &#123;if (_collectionView != collectionView || _collectionView.dataSource != self) &#123;_collectionView = collectionView;_collectionView.dataSource = self;[self updateCollectionViewDelegate];[self updateAfterPublicSettingsChange];&#125;&#125; 其中self是指适配器对象。接着适配器作为实现数据源协议的对象，我们来看一下它是怎么联系SectionController群的。123456789- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123;IGListSectionController&lt;IGListSectionType&gt; *sectionController = [self.sectionMap sectionControllerForSection:indexPath.section];_isDequeuingCell = YES;UICollectionViewCell *cell = [sectionController cellForItemAtIndex:indexPath.item];_isDequeuingCell = NO;[self mapCell:cell toSectionController:sectionController];return cell;&#125; 可以看到adapter通过遍历自己的sectionController的map来达到UICollectionView的数据源在cellForItem如何选择对应的sectionController。坦白说，这样做，给人一种全新的思路，而且以后就算自己实现其实也并不复杂，可以参考其设计。 #WorkRange能做的事什么是WorkRange？还是用Github的官方介绍说的更快，更清楚。 大体就是说，我们可以指定左右的Working区间，干一些准备工作。官网写的不多，只说了我们可以干事，具体干啥事，在我的个人实践中，我对它使用的理解是这样的。 更新数据源及预排版在ViewController进行，为Item设置layout属性。这样在SectionController中可以无需计算直接使用排版数据。12345678910111213141516171819202122func updateItem(withItems items:Array&lt;CommentItem&gt;) &#123;/*假设我们在viewController中更新数据源，item为数据模型Items = [CommentItem(name: &quot;Mike&quot;, comment: &quot;&quot;),CommentItem(name: &quot;Chen&quot;, comment: &quot;&quot;),....]*/ commentGroup = CommentGroup(Items: Items)let queue = DispatchQueue(label: &quot;myBackgroundQueue&quot;)queue.async &#123;for item in Items &#123;let layout = CommentMainItemLayout(commentItem: item)item.layout = layout&#125;self.commentModels.append(self.commentGroup!)DispatchQueue.main.async &#123; [weak self] inself?.commentAdapter.performUpdates(animated: true, completion: nil)&#125; &#125;&#125; 而将预下载或者预渲染工作放在workRange中。123456789func listAdapter(_ listAdapter: IGListAdapter, sectionControllerWillEnterWorkingRange sectionController: IGListSectionController) &#123;for url: object.urls &#123;ImageCache.setImage(withUrl:url) //如果需要预渲染，可自行设定&#125; &#125;func listAdapter(_ listAdapter: IGListAdapter, sectionControllerDidExitWorkingRange sectionController: IGListSectionController) &#123;ImageCache.cancel()&#125; #Display Delegate 我还没来得及用到Display Delegate，但我觉得它非常适合在显示文本的控件上使用异步绘制我们先来看一看它的调用顺序 func cellForItem(at index: Int) -&gt; UICollectionViewCell func listAdapterwillDisplay func listAdapterdidEndDisplaying 可以发现cellForItem在willDisplay前面，于是我会选择在cellForItem执行异步绘制。在listAdapterdidEndDisplaying暂停异步绘制，最大程度上防止滑动速度过快，导致白白浪费去执行绘制任务。 #和想象不一样的数据驱动当初看到github中官方给的图是这样的：我以为IGListKit里的数据驱动是类似双向绑定的结构，更新时不用手动显式的调用Update，可实际修改数据源模型，还是要显式调用 adapter.performUpdates(animated: true, completion: nil)而这句代码对应的就是123456/**Perform an update from the previous state of the data source. This is analagous to calling-[UICollectionView performBatchUpdates:completion:].open func performUpdates(animated: Bool, completion: IGListKit.IGListUpdaterCompletion? = nil) 为什么称为Never Call呢？ #再来看一下Diff算法简单来说这个算法就是计算tableView或者collectionView前后数据变化增删改移关系的一个算法，时间复杂度是O(n)，算是IGListKit的特色特点之一。其实这个算法单独拿出来不只可以计算collectionView模型，稍加改造，也适用于其他模型或者文件的变化使用的是Paul Heckel 的A technique for isolating differences between files 的算法，这份paper是收费。不过这并不妨碍我们直接看源码，我们可以看一下IGListDiff.mm文件,该算法使用C++来编写。主要是通过hashtable和新旧的两个数组结构：用简单的例子来说，这里我模拟的是从假设原来的 1，2，4，1的旧数据模型到新的1，2，3，5的数据模型的变化过程，假想成Swift中代码，应该是这样的:1234567891011121314151617181920let oldModel = [Num(id: 1, name: &quot;1&quot;),Num(id: 2, name: &quot;2&quot;),Num(id: 3, name: &quot;4&quot;),Num(id: 4, name: &quot;1&quot;),]let newModel = [Num(id: 1, name: &quot;1&quot;),Num(id: 2, name: &quot;2&quot;),Num(id: 3, name: &quot;3&quot;),Num(id: 4, name: &quot;5&quot;),]let result = IGListDiffPaths(0, 0, from, to, .equality).forBatchUpdates()tableView.beginUpdates()tableView.deleteRows(at: result.deletes, with: .fade)tableView.insertRows(at: result.inserts, with: .fade)for move in result.moves &#123;tableView.moveRow(at: move.from, to: move.to)&#125;tableView.endUpdates() 首先oldIndexs是一个栈的结构，过程是先遍历新数组，将数组里模型的id对应的hash值作为key，找到对应的Num成员对象（实际代码中为entry，可以理解为一种抽象）的oldIndexs栈存入NSNotFound。再遍历旧数组，拿例子来说，就是将数组里模型的id 对应的hash值作为key，找到对应的Num成员对象里的oldIndexs栈增加旧数组的下标值。如果是新增加的，那么在hashtable中key对应的value存入的Num成员对象就是notfound。这样算法如图使用的数据结构（已简化，实际稍复杂些），可以绑定新旧数组的成员的对应关系，包括成员间的移动增加删除修改关系，对于像TableView或者CollectionView非常适合不过。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://chenmingjia.github.io/tags/iOS/"},{"name":"实践篇","slug":"实践篇","permalink":"http://chenmingjia.github.io/tags/实践篇/"},{"name":"框架","slug":"框架","permalink":"http://chenmingjia.github.io/tags/框架/"},{"name":"CollectionView","slug":"CollectionView","permalink":"http://chenmingjia.github.io/tags/CollectionView/"}],"keywords":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}]},{"title":"[译]使用幽灵类型的Measurements和Units ，第四部分","slug":"unitsquare","date":"2016-10-17T16:00:00.000Z","updated":"2016-11-17T06:48:07.000Z","comments":true,"path":"2016/10/18/unitsquare/","link":"","permalink":"http://chenmingjia.github.io/2016/10/18/unitsquare/","excerpt":"原文链接=https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/作者=Ole Begemann译者=与狼同行 本系列其他文章： (1) Measurements 和 Units 概览(2) 乘法和除法(3) 内容提炼(4) 幽灵类型(本文) 我之前撰写了关于标准库里新的度量值的短系列，此文是该系列的额外之作。虽然我很喜欢苹果的 API ，但我觉得探索同一问题的不同解决方案也很有意思。特别是这个问题，纯 Swift 设计是否能优于苹果的接口呢，因为苹果的接口考虑了 Objective-C 的兼容性问题。","text":"原文链接=https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/作者=Ole Begemann译者=与狼同行 本系列其他文章： (1) Measurements 和 Units 概览(2) 乘法和除法(3) 内容提炼(4) 幽灵类型(本文) 我之前撰写了关于标准库里新的度量值的短系列，此文是该系列的额外之作。虽然我很喜欢苹果的 API ，但我觉得探索同一问题的不同解决方案也很有意思。特别是这个问题，纯 Swift 设计是否能优于苹果的接口呢，因为苹果的接口考虑了 Objective-C 的兼容性问题。 苹果的设计在苹果的 API 中，开发者主要使用的数据类型是度量值 Measurement 类型，它包含一个浮点数 value 和用于测值的单位 unit ，并基于单位类型使用了泛型。 1234567struct Measurement&lt;UnitType: Unit&gt; &#123;let unit: UnitTypevar value: Double&#125;let length = Measurement(value: 5， unit: UnitLength.meters)// 长度表现为一个 Measurement&lt;UnitLength&gt; Measurement 被视为值类型——它在 Objective-C 中是类，在 Swift 中是结构体。在单位族（Unit Family）中，比如说长度或时长，被建模为类层次结构中的类型: Unit &gt; Dimension &gt; UnitLength 、 UnitDuration等等。具体的类型如米、千克，分别是它们单位族类的实例。每一个单位都是由单位的符号（如「kg」）和一个 单元转换对象组成，该对象通过编码指令来使单位转化为该单位族的基本单位。 幽灵类型如果我们将具体的单位视为一个类型而不是实例呢？假设有一些类型名为米（Meters）、千米（Kilometers），或者英里（Miles），我们可以设计一个泛型的 Measurement 类型，它只有一个存储属性来存放量值，该量值的单位可以被完整编码在自身类型中。12345678910struct MyMeasurement&lt;UnitType: MyUnit&gt; &#123;var value: Doubleinit(_ value: Double) &#123;self.value = value&#125;&#125;let length = MyMeasurement&lt;Meters&gt;(5)// length is a MyMeasurement&lt;Meters&gt; 现在我们再次审视两种方式的不同之处，苹果的设计是让单位族 length作为 Measurement 的参数，让具体的单位 米 作为该值的一部分。而我的设计是让具体的单位 米 成为泛型参数。MyMeasurement 也能被称为幽灵类型，因为泛型参数 UnitType 没有在类型声明中出现。它的用途仅仅是用于相互区分类似 MyMeasurement &lt;Meters&gt; 和 MyMeasurement &lt;Kilometers&gt; 这样的类型，这样它们就无法互相替换。我们之后将看看这样设计是否真的有用，因为你可能会争辩，用米的度量值应当能与用千米的度量值互相转换。想了解更多关于 Swift 中幽灵类型的例子，可以看 objc.org 的文章或 Johannes Weiß 的谈话。Swift标准库也在使用幽灵类型，例如 UnsafePointer 。 好处我的方法最明显的好处是比使用度量值数据类型在大小上要小 50 % ，因为对单位实例的引用不是必要的。（单位实例自身是被所有那个单位的 Measurement 类所共用的，例如 5 米 和 10 米 两个度量值引用的是同一个单位实例。）但大小尺寸上的节省优势会被潜在更大的代码量所抵消，因为编译器会为泛型类型和使用该类型的函数产生更多的特化。 由于 Unit 在苹果的 API 中为引用类型，将测量值传给函数也会带来 retain 和 release 的开销。这两个因素对一个传统 App 来说都不是很重要，我也没有展开进一步的研究，在探索这些想法的时候，它们对我来说无关紧要。 具体的设计我们现在具体说一下如何在这个系统中定义单位，所有的单位都被封装到不同的单位族中，比如长度、温度、时长。我们开始为单位族定义一个协议： 12345/// 表现为一种物理数值 或者 可以认为是 “ 单位之族 ”/// 例如: 长度， 温度， 速率.protocol UnitFamily &#123;associatedtype BaseUnit&#125; 正如苹果API中，每个单位族都会定义一个基础单位，它用于同一单位族的不同类型间的相互转换，例如长度单位族的基础单位是米。我们在 UnitFamily 协议中，把该基础单位定义为一个关联类型，这会有一个好处，基础单位会在这个类型系统中被编码，在 Foundation 库中，基础单位必须被单独记录以使得其他人用自定义的单位来扩展这个系统。 下一步是定义 MyUnit 协议以塑造具体的单位，这些单位在苹果的设计中会被定义为单位族类型的一个实例。（这里我使用 My 作为前缀来避免和苹果类型的命名冲突） 12345678/// 表现为度量值的单位/// 例如: 米， 公里， 英里， 秒， 小时， 摄氏度.protocol MyUnit &#123;associatedtype Family: UnitFamilystatic var symbol: String &#123; get &#125;static var converter: UnitConverter &#123; get &#125;&#125; 单位通过关联类型的方式来进行声明其所属的单位族。用静态属性来保存它的符号（比如米的符号是 m ，磅的符号是 lbs ）和它的单位转化器，转化器描述了如何将该单位转化为该族的基础单位。假如说长度单位族的基础单位是米，那么公里单位的转化器应该就是 UnitConverterLinear(coefficient: 1000)。基础单位自身的转化器系数应该为1。我这里从 Foundation 库中借用了UnitConverter 类型。 Foundation 库将没有维度单位的 Unit 和有维度单位的 Dimension 进行了区分。简单起见，我们就不做这些事了，我们所有的单位都是有维度的。基础单位也必须是一个单位类型，这样想当然没错，理想来说在 UnitFamily 协议中的 BaseUnit 应当有一个对应的基础单位约束，那就是 MyUnit 。不过遗憾的是，这样会使得两个协议之间产生循环引用，这样在Swift中肯定是不被许可的。话虽如此说，但即便没有约束，一切也能工作顺利。 遵守协议现在来为协议添加具体的实现。我这里展示一下长度、速度和时长的例子，每个都设置几个单位，再添加更多的单位和单位族也没什么意义。我选择用枚举来作为类型的结构，因为无例枚举不能被实例化，这对我们来说非常完美，因为我们只对类型感兴趣，而不是对类型的实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455enum Length: UnitFamily &#123;typealias BaseUnit = Meters&#125;enum Meters: MyUnit &#123;typealias Family = Lengthstatic let symbol = &quot;m&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)&#125;enum Kilometers: MyUnit &#123;typealias Family = Lengthstatic let symbol = &quot;km&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 1000)&#125;// MARK: - Durationenum Duration: UnitFamily &#123;typealias BaseUnit = Seconds&#125;enum Seconds: MyUnit &#123;typealias Family = Durationstatic let symbol = &quot;s&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)&#125;enum Minutes: MyUnit &#123;typealias Family = Durationstatic let symbol = &quot;min&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 60)&#125;enum Hours: MyUnit &#123;typealias Family = Durationstatic let symbol = &quot;hr&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 3600)&#125;// MARK: - Speedenum Speed: UnitFamily &#123;typealias BaseUnit = MetersPerSecond&#125;enum MetersPerSecond: MyUnit &#123;typealias Family = Speedstatic let symbol = &quot;m/s&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)&#125;enum KilometersPerHour: MyUnit &#123;typealias Family = Speedstatic let symbol = &quot;km/h&quot;static let converter: UnitConverter = UnitConverterLinear(coefficient: 1.0/3.6)&#125; 转换度量值现在我们已经可以用不同的单位来表示度量值，接着我们需要让它们相互转换。converted(to:) 方法传入一个目标单位类型的参数并通过单位转换器返回那个单位新的度量值。注意这句约束TargetUnit.Family == UnitType.Family，它限制了转换只能适用于同单位族，编译器不会让你把Meters转换为Seconds。 123456789extension MyMeasurement &#123;/// Converts `self` to a measurement that has another unit of the same family.func converted&lt;TargetUnit&gt;(to target: TargetUnit.Type) -&gt; MyMeasurement&lt;TargetUnit&gt;where TargetUnit: MyUnit， TargetUnit.Family == UnitType.Family&#123;let valueInBaseUnit = UnitType.converter.baseUnitValue(fromValue: value)let valueInTargetUnit = TargetUnit.converter.value(fromBaseUnitValue: valueInBaseUnit)return MyMeasurement&lt;TargetUnit&gt;(valueInTargetUnit)&#125; 我们来为 MyMeasurement 添加一些方便的功能，遵守CustomStringConvertible是一个输出调试的良好方案，并通过遵守 ExpressibleByIntegerLiteral 和 ExpressibleByFloatLiteral 协议使得通过字面量创建新的度量值变得更加轻松愉快。 1234567891011121314151617extension MyMeasurement: CustomStringConvertible &#123;var description: String &#123;return &quot;\\(value) \\(UnitType.symbol)&quot;&#125;&#125;extension MyMeasurement: ExpressibleByIntegerLiteral &#123;init(integerLiteral value: IntegerLiteralType) &#123;self.value = Double(value)&#125;&#125;extension MyMeasurement: ExpressibleByFloatLiteral &#123;init(floatLiteral value: FloatLiteralType) &#123;self.value = value&#125;&#125; 用法现在我们开始创造一些度量值并把它们转换为其他单位，应用字面量的语法来表达对象创建非常不错。 12345678let fiveMeters: MyMeasurement&lt;Meters&gt; = 5// → 5.0 mlet threeKilometers: MyMeasurement&lt;Kilometers&gt; = 3// → 3.0 kmthreeKilometers.converted(to: Meters.self)// → 3000.0 mthreeKilometers.converted(to: Seconds.self)// error: &apos;Family&apos; (aka &apos;Length&apos;) is not convertible to &apos;Family&apos; (aka &apos;Duration&apos;) (as expected) 我们再来看看把度量值作为函数参数会怎么样？看一下这个假想的delay函数，它以时长和一个闭包作为参数，并在具体时长后执行闭包: 123func delay(after duration: MyMeasurement&lt;Seconds&gt;， block: () -&gt; ()) &#123;// ...&#125; 这个函数需要以秒为单位的度量值，如果你传入了毫秒作为参数，你必须负责转化值。以 TimeInterval 作为参数可以具有类型安全的优势，编译器不会允许你传入 MyMeasurement&lt;Milliseconds&gt; 作参数，但这样做会比我们使用 Measurement&lt;UnitDuration&gt; 要大大降低灵活性，使用后者将会允许我们传入任意的时长单位。 我们通过基于单位类型将函数泛型化实现它(并且附上约束，它的单位族必须为时长) 12345func delay&lt;Time&gt;(after duration: MyMeasurement&lt;Time&gt;， block: () -&gt; ())where Time: MyUnit， Time.Family == Duration&#123;// ...&#125; 这种写法会有用，但会大大降低函数签名的可读性，即便是在 Where 子句的位置被转移之后。 但就这一条理由来说，苹果将单位设为实例而不是类型的做法可能更为实用，更有意义。毕竟，米和公里只是同一东西的不同说法而已。但探索这个问题并不是很有意义，我们还是先继续。 加法和标量乘法有时候我们需要把同样单位族的两个度量值作加法，即便他们有不同单位。通过使用泛型来重载 + 运算符方法就会容易，并且在习惯上我们会把右边的值转化为左边值得单位，并返回基于那个单位的结果。 1234567891011func + &lt;Unit1， Unit2&gt; (lhs: MyMeasurement&lt;Unit1&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Unit1&gt;where Unit1: MyUnit， Unit2: MyUnit， Unit1.Family == Unit2.Family&#123;let rhsConverted = rhs.converted(to: Unit1.self)return MyMeasurement(lhs.value + rhsConverted.value)&#125;fiveMeters + threeKilometers// → 3005.0 mthreeKilometers + fiveMeters// → 3.005 km 我们再来注意一下这个约束 Unit1.Family == Unit2.Family ，它防止秒和米相加。 标量乘法就更容易实现了，因为没有单位转换参与。我们简单的把值相乘并创造一个新的度量值，两个重载方法被用于 a * b 和 b * a 两种情况。 123456789101112131415func * &lt;UnitType&gt; (measurement: MyMeasurement&lt;UnitType&gt;， scalar: Double) -&gt; MyMeasurement&lt;UnitType&gt; &#123;var result = measurementresult.value *= scalarreturn result&#125;func * &lt;UnitType&gt; (scalar: Double， measurement: MyMeasurement&lt;UnitType&gt;) -&gt; MyMeasurement&lt;UnitType&gt; &#123;return measurement * scalar&#125;threeKilometers * 2// → 6.0 kmlet twoSeconds: MyMeasurement&lt;Seconds&gt; = 260 * twoSeconds// → 120.0 s 如果你记得这个系列的第二部分，我最初的目的是想让单位之间可以被设计得相互依赖，例如 速度 = 路程 / 时间 或者 能量 = 功率 × 时间 。为了做到这些，我要介绍一个协议叫做 UnitProduct，通过遵守该协议和命名作为关联类型的因子，这样单位族可以表示其因子。 我们又做同样的事，但这次展示不同单位的关系而不是单位族。 123456/// Describes this relation between units:/// Product = Factor1 * Factor2protocol Product: MyUnit &#123;associatedtype Factor1: MyUnitassociatedtype Factor2: MyUnit&#125; 注意一下这样一个简单的协议足以描述乘法性和除法性关系，因为 a = b × c 等价于 b = a / c。选择结果是随意的，这样无论怎么选都会让这个关系看上去不自然。举例来说，假如我们想表示 速度 = 路程 / 时间，我们就得也把它重写为 路程 = 速度 × 时间 。下一步来实现实际计算，即重载作用于遵守协议的类型的乘法和除法运算符方法。我们需要四个变量：a = b × c泛型约束让它看起来更加复杂了，对于任意遵守 Product 协议的 Result 类型，这个重载方法定义两个度量值的乘法，这两个度量值的单位 Unit1 和 Unit2 有着和 Result的 Result.Factor1和 Result.Factor2同样的单位族。而结果是通过将度量值各自转化为 Result.Factor1 和 Result.Factor2 ，然后相乘。 1234567func * &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Unit1&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Result&gt;where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family&#123;let left = lhs.converted(to: Result.Factor1.self)let right = rhs.converted(to: Result.Factor2.self)return MyMeasurement(left.value * right.value)&#125; a = c × b 12345func * &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Unit2&gt;， rhs: MyMeasurement&lt;Unit1&gt;) -&gt; MyMeasurement&lt;Result&gt;where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family&#123;return rhs * lhs&#125; 这和先前的函数不完全类似，它将 lhs和 rhs 置换了。实现方式仅仅是转发给其他重载方法。 b = a / c and c = a / b 12345678910111213func / &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Result&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Unit1&gt;where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family&#123;let right = rhs.converted(to: Result.Factor2.self)return MyMeasurement(lhs.value / right.value)&#125;func / &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Result&gt;， rhs: MyMeasurement&lt;Unit1&gt;) -&gt; MyMeasurement&lt;Unit2&gt;where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family&#123;let right = rhs.converted(to: Result.Factor1.self)return MyMeasurement(lhs.value / right.value)&#125; 同样的方式，不过泛型参数的位置发生了变化。 具体实现现在它终于可以表示关系 路程 = 速度 × 时间（即 速度 = 路程 / 时间） 1234extension Meters: Product &#123;typealias Factor1 = MetersPerSecondtypealias Factor2 = Seconds&#125; 它可以这样用: 1234567891011let tenMeters: MyMeasurement&lt;Meters&gt; = 10let fourSeconds: MyMeasurement&lt;Seconds&gt; = 4let speed: MyMeasurement&lt;MetersPerSecond&gt; = tenMeters / fourSeconds// → 2.5 m/slet thirtyKilometersPerHour: MyMeasurement&lt;KilometersPerHour&gt; = 30let twoHours: MyMeasurement&lt;Hours&gt; = 2let tripLength: MyMeasurement&lt;Meters&gt; = thirtyKilometersPerHour * twoHours// → 60000.0 mtripLength.converted(to: Kilometers.self)// → 60.0 km 它的工作效果不错，但是有两个明显的缺点。第一个是目前的编译器无法推断出自动计算的返回类型，我不知道是否今后的编译器可以解决这个问题，也许我可以通过在函数中设置更好的泛型约束的方式提供一些帮助，但是尝试之后，依然没能解决问题。第二点是参数的单位需要有正确的单位族，返回类型的单位会被使用 Product 协议的具体单位所限制。因此类似 let tripLength: MyMeasurement&lt;Kilometers&gt; = ... 并不会起作用，你必须先提供以米形式的结果，然后再把它转换。这是一个非常大的限制。 结论忽略这个设计的缺陷（确实存在），你得注意不止一行可执行代码需要为类型系统增加数学关系！仅仅通过添加协议一致（即定义两个关联类型），我们就可以从字面上把任务 1 meter = 1 m/s × 1 s 添加给编译器的“真理”池。但如果你要添加其他数学关系（比如1 J = 1 W × 1 s），那么我们就必须再添加一个协议一致。我觉得这种写法非常吸引我。但尽管如此，我不认为这个基于幽灵类型的 API 优于苹果基础库中的 API，基于单位族而不是单位的度量值其实只会更加有意义。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://chenmingjia.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://chenmingjia.github.io/tags/Swift/"},{"name":"翻译","slug":"翻译","permalink":"http://chenmingjia.github.io/tags/翻译/"}],"keywords":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://chenmingjia.github.io/categories/iOS开发/"}]}]}