<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[[iOS]界面性能优化-总览]]></title>
      <url>http://chenmingjia.github.io/2016/11/20/20161120%20%20%5BiOS%5D%E7%95%8C%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%80%BB%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>本文整理自 ibireme  iOS 保持界面流畅的技巧:<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>
<h1 id="一、深入原理"><a href="#一、深入原理" class="headerlink" title="一、深入原理"></a>一、深入原理</h1><h2 id="1-1软件组成"><a href="#1-1软件组成" class="headerlink" title="1.1软件组成"></a>1.1软件组成</h2><p><img src="http://upload-images.jianshu.io/upload_images/712028-061b3acbcc6da403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2B68C0E2-C8D4-4752-A872-79340CC6EE0B.png"><br>Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。它并发的本性让它能高效的将不同纹理合成起来。GPU 非常快，并且比 CPU 使用更少的电来完成工作。<strong>虽然CPU可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。</strong><br>OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。对大多数人来说，OpenGL 看起来非常底层，但是当它在1992年第一次发布的时候(20多年前的事了)是第一个和图形硬件(GPU)交流的标准化方式，这是一个重大的飞跃，程序员不再需要为每个GPU重写他们的应用了。<br>OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。事情变得使人更加困惑，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。</p>
<h2 id="1-2硬件参与者"><a href="#1-2硬件参与者" class="headerlink" title="1.2硬件参与者"></a>1.2硬件参与者</h2><p><img src="http://upload-images.jianshu.io/upload_images/712028-71976fe4e46ce005.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1BEBB2A5-A8B6-47A4-B592-9229C2C5F795.png"><br>正如上面这张简单的图片显示那些挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p>
<p>下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>
<p>最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p>
<h2 id="1-3合成"><a href="#1-3合成" class="headerlink" title="1.3合成"></a>1.3合成</h2><p>在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。在许多方面显得显而易见，而让人忘了背后错综复杂的计算。</p>
<p>让我们忽略一些难懂的事例并且假定屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。</p>
<p>在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成大概的意思。</p>
<p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p>
<p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R = S + D * ( 1 – Sa )</div></pre></td></tr></table></figure></p>
<p>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。</p>
<h2 id="1-4屏幕显示图像的原理"><a href="#1-4屏幕显示图像的原理" class="headerlink" title="1.4屏幕显示图像的原理"></a>1.4屏幕显示图像的原理</h2><p><img src="http://upload-images.jianshu.io/upload_images/712028-a4caf1eae571ba2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![Uploading A078D0C0-1455-4D2D-A6DC-4399E8DBBBDE_097207.png . . .]"></p>
<p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-20d8a670177b1504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A078D0C0-1455-4D2D-A6DC-4399E8DBBBDE.png"></p>
<p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-7ad7663cab9ca96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="77C9F3D8-F098-4867-B79D-D63B0F655812.png"><br>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<p>那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p>
<h1 id="原理扩展"><a href="#原理扩展" class="headerlink" title="原理扩展"></a>原理扩展</h1><h2 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h2><p>当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。但是没有方法能告诉 GPU 纹理上的像素是透明还是不透明的。只有当你作为一名开发者知道你放什么到 CALayer 上了。这也是为什么 CALayer 有一个叫做 opaque 的属性了。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。</p>
<p>所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。</p>
<p>##离屏渲染(Offscreen Rendering)</p>
<ol>
<li><strong>On-Screen Rendering</strong><br>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li>
<li><strong>Off-Screen Rendering</strong><br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</li>
<li><strong>CPU:Off-Screen Rendering</strong><br>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。</li>
</ol>
<p>离屏渲染直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。因为这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。<br><strong>何为上下文切换</strong><br>上下文切换，不管是在GPU渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到On-Screen Rendering或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次mask的渲染操作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-f0ede82585fb3e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="56A0970F-42AF-4DB6-AB37-311C95EC5C8B.png"><br>一次mask发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次mask需要渲染三次才能在屏幕上显示，这已经是普通视图显示3陪耗时，若再加上下文环境切换，一次mask就是普通渲染的30倍以上耗时操作。问我这个30倍以上这个数据怎么的出来的？当我在cell的UIImageView的实例增加到150个，并去掉圆角的时候，帧数才跌至28帧每秒。虽然不是甚准确，但至少反映mask这个耗时是无mask操作的耗时的数十倍的。</p>
<p>当使用<strong>圆角，阴影，遮罩</strong>的时候，图层属性的无法被指定为在未预合成之前不能直接在屏幕中绘制，因为它们还需要一些屏幕外的内容来决定实际需要渲染的内容，所以就需要屏幕外来唤起渲染。</p>
<p>你可以通过设置 <strong>shouldRasterize 为 YES</strong> 来触发存储离屏渲染的缓存。同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。<br><strong>如果每帧之间变化很多，反而会带来性能负担</strong></p>
<blockquote>
<p><strong>其中shouldRasterize（光栅化）是比较特别的一种：</strong><br>光栅化概念：将图转化为一个个栅格组成的图象。<br>光栅化特点：每个元素对应帧缓冲区中的一像素。<br>shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。<br>相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。<br>当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。</p>
</blockquote>
<p>#异步绘图<br>CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。</p>
<p>当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 -drawRect:/-drawInContext: 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。</p>
<p>这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。</p>
<p>对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。</p>
<h1 id="二、卡顿产生的原因–CPU"><a href="#二、卡顿产生的原因–CPU" class="headerlink" title="二、卡顿产生的原因–CPU"></a>二、卡顿产生的原因–CPU</h1><p><img src="http://upload-images.jianshu.io/upload_images/712028-e3fe7d9bd725f360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0B0E07FF-74BA-4806-8098-4009CE76EBD1.png"><br>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p><strong>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</strong></p>
<h2 id="2-1对象创建"><a href="#2-1对象创建" class="headerlink" title="2.1对象创建"></a>2.1对象创建</h2><p>1.<strong>尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。</strong><br>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。<br>2.<strong>通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</strong><br>3.<strong>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</strong></p>
<h2 id="2-2对象调整"><a href="#2-2对象调整" class="headerlink" title="2.2对象调整"></a>2.2对象调整</h2><p><strong> 1.对此你在应用中，应该尽量减少不必要的属性修改。</strong><br>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。<br><strong>2.当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</strong></p>
<h2 id="2-3-对象销毁"><a href="#2-3-对象销毁" class="headerlink" title="2.3 对象销毁"></a>2.3 对象销毁</h2><p><strong>如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</strong><br>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *tmp = self.array;</div><div class="line">self.array = nil;</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">[tmp class];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="2-4-布局计算"><a href="#2-4-布局计算" class="headerlink" title="2.4 布局计算"></a>2.4 布局计算</h2><p><strong>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</strong></p>
<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>
<h2 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h2><p><strong>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。</strong>具体数据可以看这个文章：<a href="http://pilky.me/36/。" target="_blank" rel="external">http://pilky.me/36/。</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
<h2 id="2-5文本渲染"><a href="#2-5文本渲染" class="headerlink" title="2.5文本渲染"></a>2.5文本渲染</h2><p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），<strong>其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。</strong><br>尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<h2 id="2-6文本计算"><a href="#2-6文本计算" class="headerlink" title="2.6文本计算"></a>2.6文本计算</h2><p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：<strong>用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</strong></p>
<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<h2 id="2-7-图片的解码"><a href="#2-7-图片的解码" class="headerlink" title="2.7 图片的解码"></a>2.7 图片的解码</h2><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。<strong>图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</strong>如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<h2 id="2-8-图像的绘制"><a href="#2-8-图像的绘制" class="headerlink" title="2.8 图像的绘制"></a>2.8 图像的绘制</h2><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。<strong>由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。</strong>一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)display &#123;</div><div class="line">dispatch_async(backgroundQueue, ^&#123;</div><div class="line">CGContextRef ctx = CGBitmapContextCreate(...);</div><div class="line">// draw in context...</div><div class="line">CGImageRef img = CGBitmapContextCreateImage(ctx);</div><div class="line">CFRelease(ctx);</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">layer.contents = img;</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="三、卡顿产生的原因–GPU"><a href="#三、卡顿产生的原因–GPU" class="headerlink" title="三、卡顿产生的原因–GPU"></a>三、卡顿产生的原因–GPU</h1><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<h2 id="3-1纹理的渲染"><a href="#3-1纹理的渲染" class="headerlink" title="3.1纹理的渲染"></a>3.1纹理的渲染</h2><p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。<strong>当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。</strong>避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p>
<h2 id="3-2视图的混合-Composing"><a href="#3-2视图的混合-Composing" class="headerlink" title="3.2视图的混合 (Composing)"></a>3.2视图的混合 (Composing)</h2><p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<h2 id="3-3图形的生成。"><a href="#3-3图形的生成。" class="headerlink" title="3.3图形的生成。"></a>3.3图形的生成。</h2><p><strong>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。</strong>当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 <strong>CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。</strong>对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<p>#四、优化方案</p>
<h2 id="4-1预排版"><a href="#4-1预排版" class="headerlink" title="4.1预排版"></a>4.1预排版</h2><p>当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p>
<p>对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：FDTemplateLayoutCell。</p>
<h2 id="4-2预渲染"><a href="#4-2预渲染" class="headerlink" title="4.2预渲染"></a>4.2预渲染</h2><p>微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p>
<p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p>
<h2 id="4-3异步绘制"><a href="#4-3异步绘制" class="headerlink" title="4.3异步绘制"></a>4.3异步绘制</h2><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：YYAsyncLayer。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p>
<p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p>
<p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[iOS]深入理解并发--锁]]></title>
      <url>http://chenmingjia.github.io/2016/11/16/unitsquare/</url>
      <content type="html"><![CDATA[<p>#一、锁的基本介绍</p>
<p>###1.1为什么需要锁？？<br><strong>(1)解决资源共享问题</strong><br>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-d4e125a1d1345748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C2A1576F-C030-4683-B461-132A8D7B45D5.png"></p>
<p>这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>
<p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（乱序执行）。<br><strong>(2)并发编程为什么难？什么是重排序？</strong><br>重排序分为两类：编译期重排序和运行期重排序(乱序执行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">假设x,y初始都为0,请问r1、r2最终为什么会是0？</div><div class="line">Thread1 ：</div><div class="line">x=1；</div><div class="line">r1=y；</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Thread2 ：</div><div class="line">y=1；</div><div class="line">r2=x；</div></pre></td></tr></table></figure>
<p>这是并发编程非常经典一个问题。在了解乱序执行之前，大多数我们一定会认为答案一定在0,1、1,0、1,1这三者之间。事实上,这题目还肯定存在0，0的结果。<br>我们总是想当然的认为x=1一定会发生在r1=y之前，事实上，编译器会乱序执行，因为它认为在当前线程打乱顺序是无所谓的。但其实它对另外一个线程同时使用的变量来说非常重要。</p>
<p><strong>类似的情况还有很多,现代微处理器的设计使用了数据缓存、指令重叠执行和内存乱序访问。</strong><br><strong>如果没有做好共享数据的同步，很容易出现各种看似诡异的问题。</strong></p>
<p>###1.2锁的各个性能<br><img src="http://upload-images.jianshu.io/upload_images/712028-650341f5957b84f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C2FA214E-1254-4F09-9753-FA444D65A474.png"><br>看到除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的。有消息称，苹果在新系统中已经优化了 pthread_mutex 的性能，所以它看上去和 OSSpinLock 差距并没有那么大了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-6c504a97e51bb27a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CA403DFB-1C01-468C-B000-9020CEB866F9.png"><br>上图是常规的锁操作性能测试(iOS7.0SDK，iPhone6模拟器，Yosemite 10.10.5)，垂直方向表示耗时，单位是秒，总耗时越小越好，水平方向表示不同类型锁的锁操作，具体又分为两部分，左边的常规lock操作(比如NSLock)或者读read操作(比如ANReadWriteLock)，右边则是写write操作，图上仅有ANReadWriteLock和ANRecursiveRWLock支持，其它不支持的则默认为0，图上看出，单从性能表现，原子操作是表现最佳的(0.057412秒)，@synchronized则是最耗时的(1.753565秒) (<a href="https://github.com/SpringOx/ANLock" target="_blank" rel="external">测试代码</a>)<br>正如前文所述，不同方案各有侧重，适用于不用的场景，不能唯性能论高低：<br>原子操作虽然性能很好，但仅限于set/get，比如对列表的插入移除操作需要做同步则无能为力，支持不到，所以适用于一些实例成员变量的读写同步；</p>
<p>##二、互斥锁mutex</p>
<p>###2.1基本概念<br>互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-6394324cd13e9598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AD1300C2-2DF2-43D8-99BE-7EA25E6CDAA7.png"><br>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。<br>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。</p>
<p>###2.2实际使用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-c2d5d99ae4fb9cfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="67E8D3CF-DCA8-443C-A889-3B2BBB75F516.png"></p>
<p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</p>
<p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p>
<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。</p>
<p>###2.3pthread_mutex的实现与NSLock<br>互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。</p>
<p>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。</p>
<p>另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p>
<hr>
<p>NSLock、NSRecursiveLock是典型的面向对象的锁，即同步锁类，遵循Objective-C的NSLocking协议接口，前者支持tryLock，后者支持递归(可重入)；<br>它的实现非常简单，通过宏，定义了lock方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define    MLOCK \</div><div class="line">- (void) lock\</div><div class="line">&#123;\</div><div class="line">  int err = pthread_mutex_lock(&amp;_mutex);\</div><div class="line">  // 错误处理 ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NSLock只是在内部封装了一个pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部pthread_mutex<br>互斥锁的类型不同。通过宏定义，可以简化方法的定义。<br>NSLock比pthread_mutex略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p>
<p>###2.4性能与使用场景<br>pthread_mutex是pthread经典的基于互斥量机制的同步锁，特性、性能以及稳定各方面都已被大量项目所验证，也是比较推荐作为常规同步锁首选</p>
<p>###三、自旋锁OSSpinLock<br>iOS/MacOS自有的自旋锁，其特点是线程等待取锁时不进内核，线程因此不挂起，直接保持空转，这使得它的锁操作开销降得很低，OSSpinLock是不支持递归的；</p>
<p>###3.1基本使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    OSSpinLockLock(&amp;theLock);</div><div class="line">    sleep(1);</div><div class="line">    NSLog(@&quot;需要线程同步的操作2&quot;);</div><div class="line">    OSSpinLockUnlock(&amp;theLock);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>###3.2基本原理<br>自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">do &#123; </div><div class="line">      Acquire Lock Critical section // </div><div class="line">      临界区 Release Lock </div><div class="line">      Reminder section  // 不需要锁保护的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。</p>
<p>自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁</div><div class="line">do &#123;</div><div class="line">        while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 </div><div class="line">        lock = true; // 挂上锁，这样别的线程就无法获得锁 </div><div class="line">    Critical section // 临界区           </div><div class="line">        lock = false; // 相当于释放锁，这样别的线程可以进入临界区 </div><div class="line">     Reminder section // 不需要锁保护的代码 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释写得很清楚，就不再逐行分析了。可惜这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。</p>
<p>###3.3原子操作<br>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。</p>
<p>然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。</p>
<p>这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁</div><div class="line">do &#123;</div><div class="line"> while(test_and_set(&amp;lock); // test_and_set 是一个原子操作</div><div class="line"> Critical section // 临界区</div><div class="line"> lock = false; // 相当于释放锁，这样别的线程可以进入临界区 </div><div class="line">Reminder section // 不需要锁保护的代码</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>###3.4致命缺点<br>(1)<strong>安全问题，优先级反转</strong><br>(2)<strong>如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。</strong></p>
<p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p>
<p>得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段；‘</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-8dcfdbf5b986a3b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![F8D8D08F-F1C3-4612-8800-716B0F3C0BFB.png](http://upload-images.jianshu.io/upload_images/712028-4c440040f26ca1bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p>
<p>###3.1什么是优先级反转？<br>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-8f6def0e5ff339e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="672BC89F-8108-4AF9-A0B4-ED61D347507E.png"><br>从中得到的教训是，使用不同优先级听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p>
<p>###为什么其他锁不会发生优先级反转？</p>
<p>#3.6使用场景<br><strong>自旋锁适合短时间的操作，加锁性能最快，但不能使用不同优先级。</strong></p>
<p>##四、读写锁</p>
<p>###4.1</p>
<p>###4.2</p>
<p>###4.3性能<br>读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响；以pthread_mutex和ANRecursiveRWLock为例，假设mutex的lock耗时为lk，则rw的read lock耗时为2.7lk(从性能测试图表数据得出)，read操作耗时为rd，1000次的多线程接口访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 = 1000*lk + 1000*rd</div><div class="line">rw总耗时 = 1000*2.7*lk + 1000/c*rd</div></pre></td></tr></table></figure></p>
<p>其中c表示应用的并发数，根据开发文档和技术资料，iOS第二条线程起stack为512KB，而单个应用useable memory size在50MB以内，即c&lt;=100；<br>假设线程数取中值c=50(严格来说，线程数不等于冲突计数，冲突计数很可能会比线程数小得多，线程同步运行不代表就即刻会发生冲突)，当 mutex总耗时 &gt; rw总耗时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 &gt; rw总耗时  =》 50*lk + 50*rd &gt; 50*2.7lk + rd  =》 49*rd &gt; 85*lk   =》 rd &gt; 1.73*lk</div></pre></td></tr></table></figure></p>
<p>可以看出，只要read操作耗时超过锁操作耗时的1.7倍(这其实很容易达到的)，读写锁的性能就会占优势<br>假设线程数c=2(如上述，这里是假设了两个线程之间是竞争了，发生冲突，实际未必)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 &gt; rw总耗时  =》 2*lk + 2*rd &gt; 5.4*lk + rd  =》 rd &gt; 3.4lk</div></pre></td></tr></table></figure></p>
<p>即使只有两个并发线程，只要read操作耗时超过锁操作耗时的3.4倍，读写锁的性能还会占优势<br>假设线程数c=1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 &gt; rw总耗时  =》0 &gt; 1.7lk</div></pre></td></tr></table></figure></p>
<p>这显然不成立，说明当单个线程的时候，rw的性能不可能有优势。这也好理解，这时候的mutex和rw的读操作都相当完全同步，不论是mutex还是rw，性能完全取决于锁操作本身，而rw在锁操作耗时上就不占优势，所以mutex总耗时总是要小于rw总耗时的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-653a089bebdf30c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![B9FAA079-DFA3-4620-B06D-B0597C29F8CF.png](http://upload-images.jianshu.io/upload_images/712028-23114f92b41d5697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-1d47726c9b8f58f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D0D6390E-3A1E-46D1-9A0A-055E853CA235.png"><br>上图是mutex锁和rw锁read操作的耗时测试用例，下图为测试结果，read操作设置为100微秒，mutex锁的总耗时是rw锁的5倍多，read操作的耗时远比锁操作大许多(2k倍)，根据上述恒等式计算可以得出实际的冲突计数c=5</p>
<p>###五、信号量</p>
<p>###5.1基本概念</p>
<p>###5.2基本原理<br>dispatch_semaphore的性能表现出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制，是否适用于常规同步锁有待实践验证。不做推荐<br>信号量dispatch_semaphore_t的实现原理，它最终会调用到sem_wait<br>方法，这个方法在 glibc 中被实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int sem_wait (sem_t *sem) &#123;</div><div class="line">  int *futex = (int *) sem;</div><div class="line">  if (atomic_decrement_if_positive (futex) &gt; 0)</div><div class="line">    return 0;</div><div class="line">  int err = lll_futex_wait (futex, 0);</div><div class="line">    return -1;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在lll_futex_wait<br>函数中实现，<strong>lll</strong> 是 low level lock 的简称。这个函数通过汇编代码实现，调用到SYS_futex<br>这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。<br>主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。<br>可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</p>
<p>###5.3缺点<br>在时间较短的操作，没有自旋锁高效，会有上下文切换的成本。</p>
<p>###5.4优点<br>相对</p>
<p>#六、条件锁</p>
<p>###6.1基本概念<br>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</p>
<p>###6.2基本使用<br>很多介绍pthread_cond_t的文章都会提到，它需要与互斥锁配合使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void consumer () &#123; // 消费者</div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    while (data == NULL) &#123;</div><div class="line">        pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据</div><div class="line">    &#125;</div><div class="line">    // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓</div><div class="line">    // temp = data;</div><div class="line">    // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。</p>
<p>wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。</p>
<p>###为什么要使用条件变量<br>介绍条件变量的文章非常多，但大多都对一个一个基本问题避而不谈:“为什么要用条件变量？它仅仅是控制了线程的执行顺序，用信号量或者互斥锁能不能模拟出类似效果？”<br>网上的相关资料比较少，我简单说一下个人看法。信号量可以一定程度上替代 condition，但是互斥锁不行。在以上给出的生产者-消费者模式的代码中，pthread_cond_wait<br>方法的本质是锁的转移，消费者放弃锁，然后生产者获得锁，同理，pthread_cond_signal<br>则是一个锁从生产者到消费者转移的过程。<br>如果使用互斥锁，我们需要把代码改成这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void consumer () &#123; // 消费者</div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    while (data == NULL) &#123;</div><div class="line">        pthread_mutex_unlock(&amp;mutex);</div><div class="line">        pthread_mutex_lock(&amp;another_lock)  // 相当于 wait 另一个互斥锁</div><div class="line">        pthread_mutex_lock(&amp;mutex);</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做存在的问题在于，在等待 another_lock 之前， 生产者有可能先执行代码， 从而释放了 another_lock。也就是说，我们无法保证释放锁和等待另一个锁这两个操作是原子性的，也就无法保证“先等待、后释放 another_lock” 这个顺序。<br>用信号量则不存在这个问题，因为信号量的等待和唤醒并不需要满足先后顺序，信号量只表示有多少个资源可用，因此不存在上述问题。然而与pthread_cond_wait<br>保证的原子性锁转移相比，使用信号量似乎存在一定风险(暂时没有查到非原子性操作有何不妥)。<br>不过，使用 condition 有一个好处，我们可以调用pthread_cond_broadcast<br>方法通知所有等待中的消费者，这是使用信号量无法实现的。</p>
<p>#七、@synchronized</p>
<p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>
<p>我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。</p>
<p>#综合上述分析与讨论，总结有以下几点原则：<br>1、总的来看，推荐pthread_mutex作为实际项目的首选方案；<br>2、对于耗时较大又易冲突的读操作，可以使用读写锁代替pthread_mutex；<br>3、如果确认仅有set/get的访问操作，可以选用原子操作属性；<br>4、对于性能要求苛刻，可以考虑使用OSSpinLock，需要确保加锁片段的耗时足够小；<br>5、条件锁基本上使用面向对象的NSCondition和NSConditionLock即可；<br>6、@synchronized则适用于低频场景如初始化或者紧急修复使用；</p>
<p>#八、锁的第二层含义</p>
<p>一个简单的问题：在存在编译乱序与指令执行乱序的情况下，怎么保证锁所保护的代码片段，不会被提前到加锁之前，或者是放锁之后执行？如果编译器将锁保护下的代码，通过编译优化，放到了加锁之前运行？又如果CPU在执行指令时，将锁保护下的汇编代码，延迟到了放锁之后执行？如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-a937659e764d4cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5FF8FB43-6327-471D-81E4-AD0DB4CE3C1E.png"></p>
<p>如上所示，如果编译器做了它不该做的优化，或者CPU做了其不该做的乱序，那么spinlock保护下的代码片段，同一时刻，一定只有一个线程能够执行的假设被打破了。此时，虽然spinlock仍旧只能有一个线程持有，但是spinlock保护下的代码，被提到了spinlock保护之外执行，spinlock哪怕功能再强大，也不能保护锁之外的代码，提取到spinlock锁之外的代码，能够并发执行。</p>
<p>但是上面的测试说明，spinlock保护下的global_count++操作，在多线程下能够正确执行。也就说明，无论是编译器，还是CPU，并没有不合时宜的做上面的这些优化。而分析其原因，刚好引出了锁（Spinlock、Mutex、RWLock等）的第二层意义：Lock Acquire和Unlock Release。</p>
<p>什么是Lock Acquire，Unlock Release又意味着什么？在此之前，需要先看看什么是Acquire和Release。Acquire和Release语义（Semantics）是程序语言和CPU内存模型（Memory Model）中的一个概念。以下，是截取自Preshing博客《Acquire and Release Semantics》一文中，对Acquire与Release Semantics的定义：</p>
<p>Acquire semantics is a property which can only apply to operations which read from shared memory, whether they are read-modify-write operations or plain loads. The operation is then considered a read-acquire. Acquire semantics prevent memory reordering of the read-acquire with any read or write operation which follows it in program order. （注：Acquire语义是一个作用于内存读操作上的特性，此内存读操作即被视为read-acquire。Acquire语义禁止read-acquire之后所有的内存读写操作，被提前到read-acquire操作之前进行。）</p>
<p>Release semantics is a property which can only apply to operations which write to shared memory, whether they are read-modify-write operations or plain stores. The operation is then considered a write-release. Release semantics prevent memory reordering of the write-release with any read or write operation which precedes it in program order.（注：Release语义作用于内存写操作之上的特性，此内存写操作即被视为write-release。Release语义禁止write-release之前所有的内存读写操作，被推迟到write-release操作之后进行。）</p>
<p>从Acquire与Release语义的定义可以看出，两个语义对编译器优化、CPU乱序分别做了一个限制条件：</p>
<p>Acquire语义限制了编译器优化、CPU乱序，不能将含有Acquire语义的操作之后的代码，提到含有Acquire语义的操作代码之前执行；<br>acquire sematics</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-439d7cd2ee56106c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7F568A62-4FA8-49F7-BE39-B2A5A974B6FA.png"></p>
<p>Release语义限制了编译器优化、CPU乱序，不能将含有Release语义的操作之前的代码，推迟到含有Release语义的操作代码之后执行；<br>release sematics</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-ea08b284da61d69e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![Uploading 420A1577-FB42-4092-886A-CACF333A662D_050837.png . . .]"></p>
<p>有了明确的Acquire和Release语义的定义，再回过头来看前面提到的锁的第二层含义：Lock Acquire和Unlock Release。加锁操作自带Acquire语义，解锁操作自带Release语义。将加锁、解锁的两个语义结合起来，就构成了以下的完整的锁的含义图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-bb64d7b9ab48ffd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="420A1577-FB42-4092-886A-CACF333A662D.png"><br>锁含义</p>
<p>spinlock，只有带有了Acquire和Release语义，才算是一个真正完整可用的锁——Acquire与Release语义间，构成了一个临界区。获取spinlock后的线程，可以大胆的运行全局变量的读写，而不必担心其他并发线程对于此变量的并发访问。</p>
<p>好消息是，pthread lib所提供的spinlock、mutex，其加锁操作都自带了acquire语义，解锁操作都自带了release语义。因此，哪怕我们在使用的过程中，不知道有这两个语义的存在，也能够正确的使用这些锁。但是，读者需要实现自己的spinlock、mutex（注：实际情况下，确实有这个必要，数据库系统如Oracle/PostgreSQL/InnoDB，都有自己实现的Spinlock、Mutex等），那么对于锁的了解，到这个层次，是必不可少的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Math]程序员的数学整理(1)]]></title>
      <url>http://chenmingjia.github.io/2016/11/15/20161018%E5%AE%89%E5%85%A8Swift%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[[iOS]安全Swift的Unsafe]]></title>
      <url>http://chenmingjia.github.io/2016/11/15/20161018%E5%AE%89%E5%85%A8Swift%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Swift是一门以安全为设计理念的语言，但同时由于 Swift 的多样性的特点，你可能需要调用一个并不安全的 C 的 Api 如 OpenGL、POSIX。<br>这些Api需要你使用指针和手动在堆中申请内存空间。<br>在C中,你将会写下下面这样的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int *a = malloc(sizeof(int));</div><div class="line">*a = 42;</div><div class="line">printf(&quot;a&apos;s value: %d&quot;,*a)</div><div class="line">free(a)</div></pre></td></tr></table></figure></p>
<p>而这在 Swift 在这么实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1)</div><div class="line">a.pointee = 42</div><div class="line">print(&quot;a&apos;s value: \(a.pointee)&quot;) //42</div><div class="line">a.deallocate(capacity:1)</div><div class="line">print(&quot;a&apos;s value: \(a.pointee)&quot;) //无法预测</div></pre></td></tr></table></figure></p>
<p>注意!由于使用了这个Unsafe的API,在a.deallocate释放内存后，内存会被其他值写入，可能访问到随机值，而我们的指针仍然指向那块未知的内存，是十分危险的。<br>另外capacity为分配泛型实例的个数的空间。只是分配内存,但不会负责初始化。</p>
<p><strong>严格意义来说，这些并不是C语言的纯指针，而是结构体里封装一个指向内存的指针RawPointer真·指针,大小为8字节</strong></p>
<h3 id="1-1标准使用"><a href="#1-1标准使用" class="headerlink" title="1.1标准使用"></a>1.1标准使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var intPtr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1)</div><div class="line">intPtr.initialize(to: 10)</div><div class="line">intPtr.deinitialize()</div><div class="line">intPtr.deallocate(capacity: 1)</div><div class="line">intPtr = nil</div></pre></td></tr></table></figure>
<h2 id="二、UnsafeMutablePointer"><a href="#二、UnsafeMutablePointer" class="headerlink" title="二、UnsafeMutablePointer"></a>二、UnsafeMutablePointer</h2><h3 id="2-1开辟内存-amp-修改内存"><a href="#2-1开辟内存-amp-修改内存" class="headerlink" title="2.1开辟内存&amp;修改内存"></a>2.1开辟内存&amp;修改内存</h3><p>UnsafeMutablePointer<t> ,这普通的结构体相当于一个 T 的指针，正如你所示的，他有一个静态函数， allocate 将会开辟需要的内存空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let a = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 0)</div><div class="line">a.pointee = 42</div><div class="line">a.predecessor().pointee = 42</div><div class="line">a.successor().pointee = 42</div><div class="line">a.successor().successor().pointee = 42</div><div class="line">let s = a.successor()</div><div class="line">let p = a.predecessor()</div></pre></td></tr></table></figure></t></p>
<p>a为指向Int类型的指针,为8个字节。<br>successor()和predecessor()就像Array一样，可以指向前面和后面的8个字节的Int空间,因为Int是8个字节。<br>下面为内存空间的结果，2a即为42.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x1021006b8: 0x000000000000002a 0x000000000000002a</div><div class="line">0x1021006c8: 0x000000000000002a 0x000000000000002a</div><div class="line">0x1021006d8: 0x000000000000002a</div></pre></td></tr></table></figure></p>
<p>例如我们还可以用advanced来使用数组指针的其他操作,<strong>同时它也支持下标方法</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let size = 10</div><div class="line">var a = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: size)</div><div class="line">for idx in 0..&lt;10 &#123;</div><div class="line">a.advanced(by: idx).pointee = idx</div><div class="line">&#125;</div><div class="line">a.deallocate(capacity: size)</div></pre></td></tr></table></figure></p>
<p><strong>如果我们capacity写成0，程序照常运行，但是这样很有可能会覆盖其他有用的数据，因此一样合理控制。</strong></p>
<h3 id="2-2-amp-操作–获得指针"><a href="#2-2-amp-操作–获得指针" class="headerlink" title="2.2 &amp;操作–获得指针"></a>2.2 &amp;操作–获得指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func receive(mutablePointer:UnsafeMutablePointer&lt;Int&gt;)&#123;</div><div class="line">mutablePointer.pointee *= 2</div><div class="line">&#125;</div><div class="line">var a = 42</div><div class="line">receive(mutablePointer:&amp;a)</div><div class="line">print(&quot;A&apos;s value has changed in the function:\(a)&quot;) //84</div></pre></td></tr></table></figure>
<p>但是我们要知道&amp;操作在Swift中拥有限制，它只能出现在函数参数列表中。像下面这样使用,是不合法的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var g = &quot;string&quot;</div><div class="line">let k = &amp;g   //&apos;&amp;&apos; can only appear immediately in a call argument list</div></pre></td></tr></table></figure></p>
<h3 id="2-3-withUnsafeMutablePointer调用指针"><a href="#2-3-withUnsafeMutablePointer调用指针" class="headerlink" title="2.3 withUnsafeMutablePointer调用指针"></a>2.3 withUnsafeMutablePointer调用指针</h3><p>如何在不创建一个函数的情况下，调用指针。为了达到这种目的，我们需要使用  withUnsafeMutablePointer  ，他将会调用一个 Swift 的引用类型和一个有参数的  block  。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = 42</div><div class="line">withUnsafeMutablePointer(to: &amp;a)&#123; $0.pointee *= 2&#125;</div><div class="line">print(&quot;a&apos;s value is: \(a)&quot;) //84</div></pre></td></tr></table></figure></p>
<p>下面是一个实际调用C的API的一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var dirEnt: UnsafeMutablePointer&lt;dirent&gt;?</div><div class="line">var dp:UnsafeMutablePointer&lt;Dir&gt;?</div><div class="line"></div><div class="line">let data = &quot;.&quot;.data(using:ascii)</div><div class="line">data?.withUnsafeBytes(&#123;(ptr:UnsafePointer&lt;Int8&gt;) in</div><div class="line">dp = opendir(ptr)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">repeat&#123;</div><div class="line">dirEnt = readdir(dp)</div><div class="line">if let dir = dirEnt&#123;</div><div class="line">withUnsafePointer(to:&amp;dir.pointee.d_name,&#123; ptr in</div><div class="line">let ptrStr = unsafeBitCase(ptr,to:UnsafePointer&lt;CChar&gt;.self)</div><div class="line">let name = String(cString:ptrStr)</div><div class="line">print(&quot;\(name)&quot;)</div><div class="line">&#125;)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">while dirEnt != nil</div></pre></td></tr></table></figure></p>
<h2 id="三、UnsafePointer"><a href="#三、UnsafePointer" class="headerlink" title="三、UnsafePointer"></a>三、UnsafePointer</h2><h3 id="3-1使用指针"><a href="#3-1使用指针" class="headerlink" title="3.1使用指针"></a>3.1使用指针</h3><p>这个 UnsafeMutablePointer 还有一个变形—— UnsafePointer ，这个类型不允许你修改指针的值，此外不可修改的 UnsafePointer 甚至没有 allocate 方法。<br><strong>只有一个创建 UnsafePointer 方法</strong>，那就是使用 &amp; 操作。当传一个 block 或者函数，你可以使用一个 &amp; 来传入一个指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func receive(pointer:UnsafePointer&lt;Int&gt;)&#123;</div><div class="line">print(&quot;param value is:\(pointer.pointee)&quot;)    //42</div><div class="line">&#125;</div><div class="line">var a:Int = 42</div><div class="line">receive(pointer: &amp;a)</div></pre></td></tr></table></figure></p>
<h2 id="四、指针类型"><a href="#四、指针类型" class="headerlink" title="四、指针类型"></a>四、指针类型</h2><h3 id="4-1指针类型转换"><a href="#4-1指针类型转换" class="headerlink" title="4.1指针类型转换"></a>4.1指针类型转换</h3><p>当处理 C 的 API 的时候，你有时候需要将指向结构体的指针转换为不同的结构体。对于 C 的 API 的处理很简单（同时也是十分危险并且容易出现报错）的，就像你在 Swift 中所看到的，所有指针的类型是被固定的，这意味着一个  UnsafePointer<int>  的指针不能再用在需要  UnsafePointer<uint8>  的地方，这使得能够更好的编写出更加安全的代码，但是同样意味着你不能在你需要的时候随意转换指针类型。<br>我们可以使用 withMemoryRebound 这个我们用来将一个指针类型转换为另一个指针类型的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.withMemoryRebound(to: UInt8.self, capacity: 1) &#123; (ptr) in</div><div class="line">print(ptr.pointee) //ptr为UnsafePointer&lt;UInt8&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></uint8></int></p>
<h3 id="4-2Swift中的Void指针"><a href="#4-2Swift中的Void指针" class="headerlink" title="4.2Swift中的Void指针"></a>4.2Swift中的Void指针</h3><p>在 Swift 3.0 以前，你可能需要使用 UnsafePointer<void> 。然而在3.0中有一个新的类型来处理这些指针： UnsafeRawPointer 。这个结构体和不同的结构体不同，所以这意味着他不会将其中的信息绑定到任何指定的类型中，这另我们的编码过程变得很简单。为了创建一个 UnsafeRawPointer 指针，我们只需要调用它的创建函数来包裹我们所需要的那个指针。<br>如果我们想要用另外的方法，来将这个 UsafeRawPointer 的指针转化为其他类型的指针的时候，我们需要使用 withMemoryRebound 的上一个版本的方法，在这里他叫做 assumingMemoryBound 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let intPtr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1)</div><div class="line">let voidPtr = UnsafeRawPointer(intPtr)</div><div class="line">let intPtrAgain = voidPtr.assumingMemoryBound(to: Int.self)</div></pre></td></tr></table></figure></void></p>
<h3 id="4-3修改指针的值"><a href="#4-3修改指针的值" class="headerlink" title="4.3修改指针的值"></a>4.3修改指针的值</h3><p>为了更好地完成这篇文章，在这我将介绍一些 Swift 中指针的用法。 第一个就是在使用C的API的时候使用 void<em> 方法而不是使用内存地址。通常这会发生在一个函数接受不同类型的参数，并简单的将参数打包成 void</em> 类型，就像下面这个例子一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void generic_function(int value_type, void* value);</div><div class="line"></div><div class="line">generic_function(VALUE_TYPE_INT, (void *)2);</div><div class="line">struct function_data data;</div><div class="line">generic_function(VALUE_TYPE_STRUCT, (void *)&amp;data);</div></pre></td></tr></table></figure></p>
<p>如果我们想要在 Swift 中调用第一个函数，我们需要使用特别的构造函数，这会创建一个特殊的地址的。所有这些函数将不会改变允许你改变内存地址中变量的值，所以我们将会在这种情况下使用 UnsafePointer(bitPattern:)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">generic_function(VALUE_TYPE_INT, UnsafeRawPointer(bitPattern: 2))</div><div class="line">var data = function_data()</div><div class="line">withUnsafePointer(to: &amp;data, &#123; generic_function(VALUE_TYPE_STRUCT, UnsafeRawPointer($0)) &#125; )</div></pre></td></tr></table></figure></p>
<h3 id="4-4强制转换"><a href="#4-4强制转换" class="headerlink" title="4.4强制转换"></a>4.4强制转换</h3><p>unsafeBitCast是一个极度危险的操作。文档将其描述为“将某物强制转换为和其他东西相同的比特位”。在上面我们能够安全的使用它的原因是，我们只是简单的转换不同类型的指针，并且这些指针的比特位都是相同的。这也是我们为什么必须先调用withUnsafePointer来获取UnsafePointer，然后将其转换为UnsafePointer的原因。</p>
<p>在一开始这可能会造成迷惑，特别是当处理与指针相同的类型时，比如Swift里的Int（在目前所有可用的平台，一个指针的长度是一个字符，Int的长度同样也是一个字符）。<br>比如你很容易就会犯下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x: Int = 7</div><div class="line">let xPtr = unsafeBitCast(x, UnsafePointer.self)</div></pre></td></tr></table></figure></p>
<p>这段代码的意图是创造一个指针并指向x。它会给人造成误解，因为这不是一个指向x的指针，而是一个把x的值视为地址的指针，xPtr会执行0x0000000007。<br>只是这个例子中unsafeBitCast要求类型的长度相等，所以当试图转换Int8就没这么好运了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x: Int8 = 7</div><div class="line">let xPtr = unsafeBitCast(x, UnsafePointer.self)</div></pre></td></tr></table></figure></p>
<p>这段代码会简单的导致unsafeBitCast抛出异常和程序崩溃。<br><strong>另外切记不要使用unsafeBitCast做出转换同类指针的操作，比如 UnsafePointer<int>和 UnsafePointer<uint8></uint8></int></strong></p>
<h2 id="五、另一个数组指针"><a href="#五、另一个数组指针" class="headerlink" title="五、另一个数组指针"></a>五、另一个数组指针</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><p>Swift 还有一个 UnsafeBufferPointer 的结构体来更方便的实现这个需求。这个结构体是一个Swift数组和指针的桥梁。如果我们使用 UnsafePointer 来作为变量从而调用创建函数创建一个 UnsafeBufferPointer ，我们将能够使用大多数的Swift原生的数组（Array）方法，因为 UnsafeBufferPointer 遵守并实现了 Collections ， Indexable 和 RandomAccessCollection 协议。所以我们可以像这样遍历内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Using a and size from previous code </div><div class="line">var b = UnsafeBufferPointer(start: a, count: size)</div><div class="line">b.forEach(&#123;</div><div class="line">print(&quot;\($0)&quot; // Prints 0 to 9 that we fill previously </div><div class="line">)&#125;)</div></pre></td></tr></table></figure></p>
<p>当我们提到 UnsafeBufferPointer 的是一个Swift中数组的桥梁的时候，这也意味着我们很容易使用 UnsafeBufferPointer 来调用一个已经存在的数组，比如说下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5, 6]</div><div class="line">a.withUnsafeBufferPointer(&#123; ptr in</div><div class="line">ptr.forEach(&#123; print(&quot;\($0)&quot;) &#125;) // 1, 2, 3... </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="5-2-一些属性"><a href="#5-2-一些属性" class="headerlink" title="5.2 一些属性"></a>5.2 一些属性</h3><p><strong>baseAddress 是第一个元素的指针</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var array = [1, 2, 3, 4, 5]</div><div class="line">var arrayPtr = UnsafeMutableBufferPointer&lt;Int&gt;(start: &amp;array, count: array.count)</div><div class="line">// baseAddress 是第一个元素的指针</div><div class="line">var basePtr = arrayPtr.baseAddress! as UnsafeMutablePointer&lt;Int&gt;</div></pre></td></tr></table></figure></p>
<h2 id="六、Unsafe带来的破坏"><a href="#六、Unsafe带来的破坏" class="headerlink" title="六、Unsafe带来的破坏"></a>六、Unsafe带来的破坏</h2><p><strong> 1.  第一点之前已经提到，它很有可能会覆盖我们在堆上的其他数据</strong><br><strong> 2. 这个指针指向的对象很有可能已经被释放，然而Unsafe指针本身不会涉及引用计数，因为它更接近C指针的使用。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var collectionPtr: UnsafeMutableBufferPointer&lt;Int&gt;?</div><div class="line">func duplicateElements(inArray: UnsafeMutableBufferPointer&lt;Int&gt;) &#123;</div><div class="line">for i in 0..&lt;inArray.count &#123;</div><div class="line">inArray[i] *= 2</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">repeat &#123;</div><div class="line">var collection = [1, 2, 3]</div><div class="line">collection.withUnsafeMutableBufferPointer(&#123; collectionPtr = $0 &#125;)</div><div class="line">&#125; while false</div><div class="line">duplicateElements(inArray: collectionPtr!) // Crash due to EXC_BAD_ACCESS</div></pre></td></tr></table></figure></p>
<p><strong>3. 如果我们手动创建的内存没有析构,那就是内存泄漏</strong><br><strong>4. 即使指针析构以后，但没有置空，仍然会访问未知内存</strong></p>
<h3 id="七、透明指针"><a href="#七、透明指针" class="headerlink" title="七、透明指针"></a>七、透明指针</h3><p>正如这篇文章中的其他例子中所看到的。然而正如我们所看到的，这些调用在内当我们传入一个指针到 C 中来指向一个我们没有 retain 的变量的时候，这个对象将被释放，同时这个程序将会崩溃。</p>
<p>Swift 有一个实用的方法决定指向这个对象的指针是否进行 retain 。这就是 Unmanaged。使用它的 passRetained() 我们将会创建一个被 retained 的指向这个对象的指针，那么我们就能保证当他在 C 中被调用的时候他仍旧在那。当这个对象已经在回调函数中被 retianed 的时候我们可以使用 passUnretained() 。这两个方法将会产生 Unmanaged 的实例变量，这个实力变量将会通过调用 toOpaque() 方法转换为 UnsafeRawPointer。<br>在另一方面我们可以将 UnsafeRawPointer 通过相反的 API fromOpaque() 和 takeRetained() 转换为一个类或者结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void set_callback(void (*functionPtr)(void*), void* userData));</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class CallbackUserData &#123;</div><div class="line">func sayHello() &#123; print(&quot;Hello world!&quot; ) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func callback(userData: UnsafeMutableRawPointer) &#123;</div><div class="line">let callbackUserData:CallbackUserData = Unmanaged.fromOpaque(userData).takeRetainedValue()</div><div class="line"></div><div class="line">callbackUserData.sayHello() // &quot;Hello world!&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var userData = CallbackUserData()</div><div class="line">let reference = Unmanaged.passRetained(userData).toOpaque()  //引用计数+1</div><div class="line">set_callback(callback, reference)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[iOS]深入理解并发--GCD(上)]]></title>
      <url>http://chenmingjia.github.io/2016/11/15/unitsquare/</url>
      <content type="html"><![CDATA[<p>##一、Dispatch Queue</p>
<p>###1.1为什么要有线程池的概念<br>GCD 队列的内部使用的是线程。GCD 管理这些线程池,暴露 API，提供一层抽象层级。一般来说使用GCD,你只需考虑队列和功能点（提交给队列的 block）。</p>
<p><strong>GCD即便使用了线程池，也并非完全也可以脱离线程的概念，当一个完整APP里纵横n个异步线程时，GCD的线程池仍然会出现疯狂创造线程，影响主线程 </strong></p>
<p>队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程做并发时，很可能会变成分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当处理功能点时，可能会调用一些函数作为功能的一部分,写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在成了64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。</p>
<p><strong>GCD最佳线程数为当前内核数,我电脑是8核Macbook Pro,即最佳线程数为8，使用GCD最多创建68个线程。</strong></p>
<p>GCD 通过创建所谓的线程池来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题：</p>
<p><strong>如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。</strong></p>
<p>###1.2 Queue的模型演示<br><img src="http://upload-images.jianshu.io/upload_images/712028-994cedf6e1728044.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG1.jpeg"><br>首先GCD会有一个分发队列(Dispatch Queue),它允许我们去提交一些工作任务,以闭包的形式()-&gt;(),当分发开始执行时,它会建立额外的线程和服务来执行任务,当队列中的任务被分发完毕,它也会负责回收线程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-61ae3a3c09e81066.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG3.jpeg"><br>我们可以建立自己的线程,可以在该线程中跑runLoop,比如说我们的主线程,就是很特殊的,它有它自己的Main Runloop和主队列(Main Queue)。</p>
<p>###1.3 实际使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line">let queue = DispatchQueue(label: &quot;queueLabel&quot;,    //标签</div><div class="line">                          qos: .default,           //优先级</div><div class="line">                          attributes: .concurrent,        //并发还是串行</div><div class="line">                          autoreleaseFrequency: .inherit,     //释放频率</div><div class="line">                          target: nil)    //目标队列</div></pre></td></tr></table></figure></p>
<p>使用总结如下:<br><strong>优先级</strong>：<strong>如果没有特殊性能要求，应该总是用.default！！！,避免优先级反转,高手可以使用其他优先级,切记要规避自旋锁！</strong><br><strong>释放频率</strong>:inherit，workItem，never。作为Swift3出现的新属性,<strong>这个属性应该总是为.workItem！！！。</strong><br><strong>历史原因:释放频率是为了弥补以前GCD当线程不活跃时,会在开发者无法掌控的时间自动往自动释放池释放对象,而这种无法掌握的事情缺点很多,实际开发中，开发者要么自己手动创建释放池释放调度对象，要么出现内存悬挂。<br>于是Apple使用新的workitem来解决手动释放的问题,其实2个选项为了适配旧的代码,never是GCD不会为你管理自动释放池,可能为一些特殊项目使用,inherit是旧的模式，适配旧代码</strong><br>本段释放频率参考:<a href="http://stackoverflow.com/questions/38884418/autoreleasefrequency-on-dispatchqueue-in-swift-3-beta-5" target="_blank" rel="external">http://stackoverflow.com/questions/38884418/autoreleasefrequency-on-dispatchqueue-in-swift-3-beta-5</a></p>
<p>###1.4原理剖析<br>以 dispatch_queue_create 的源码为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) &#123;</div><div class="line">    // 省略 label 相关的操作</div><div class="line">    dispatch_queue_t dq;</div><div class="line">    dq = _dispatch_alloc(DISPATCH_VTABLE(queue),</div><div class="line">            sizeof(struct dispatch_queue_s) - DISPATCH_QUEUE_MIN_LABEL_SIZE -</div><div class="line">            DISPATCH_QUEUE_CACHELINE_PAD + label_len + 1);</div><div class="line">    _dispatch_queue_init(dq);</div><div class="line">    if (fastpath(!attr)) &#123;</div><div class="line">        return dq;</div><div class="line">    &#125;</div><div class="line">    if (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;</div><div class="line">        dq-&gt;dq_width = UINT32_MAX;</div><div class="line">        dq-&gt;do_targetq = _dispatch_get_root_queue(0, false);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_debug_assert(!attr, &quot;Invalid attribute&quot;);</div><div class="line">    &#125;</div><div class="line">    return dq;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <strong> fastpath </strong> 和 <strong>slowpath</strong> 是基于if判断的指令优化,第一个 if 判断中，苹果认为串行队列，或者 NULL 参数更常见，因此  !attr  的值很有可能不为 0，这与上文的结论一致。</p>
<p>第二个判断中，参数几乎有只可能是  DISPATCH_QUEUE_CONCURRENT ，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断机会不会为 0，依然与 fastpath 的作用一致。</p>
<p><strong>_dispatch_get_root_queue</strong> 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 <strong>8 个全局队列</strong>。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个<strong>线程过载(overcommit)</strong>。</p>
<p>这 8 个全局队列的序列号是 4-11，序列号为<strong> 1 的队列是主队列</strong>，<strong>2 是 manager 队列，用来管理 GCD 内部的任务</strong>(比如下文介绍的定时器)，3 这个序列号暂时没有使用。队列 的<strong> dq_width 被设置为 UINT32_MAX，表示这些队列不限制并发数</strong>。串行队列的 dq_width默认为1.</p>
<p>而最后<strong>target_queue</strong>是GCD一个非常重要的概念,向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个不支持 overcommit 的全局队列，全局队列的底层则是一个线程池。<br><img src="http://upload-images.jianshu.io/upload_images/712028-094ced243fb25913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1F471211-C38C-4934-A1B7-CC6714989B56.png"><br>上图其实有11个全局队列。没有完整。</p>
<p>##二、异步执行Asynchronous Execution</p>
<p>###2.1.闭包或block派发任务<br>闭包或block会被转化为dispatch_continuation_t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_continuation_t dc = fastpath(_dispatch_continuation_alloc_cacheonly());</div><div class="line">   dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</div><div class="line">   dc-&gt;dc_func = func;</div><div class="line">   dc-&gt;dc_ctxt = context;</div><div class="line">  _dispatch_queue_push(dq, dc);</div></pre></td></tr></table></figure></p>
<p><strong>可以理解为一个队列任务块，然后push到队列中——这里的队列是调用async的队列，如果是内部的任务，提交给_dispatch_mgr_q内部队列。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_queue_t dq, void (^work)(void))</div><div class="line">&#123;</div><div class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</div><div class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT;</div><div class="line"></div><div class="line">	_dispatch_continuation_init(dc, dq, work, 0, 0, dc_flags);</div><div class="line">	_dispatch_continuation_async(dq, dc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到闭包被封装为_dispatch_continuation，然后进行下一个函数。</p>
<p>###2.2调用过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;</div><div class="line">    dispatch_continuation_t dc;</div><div class="line">    if (dq-&gt;dq_width == 1) &#123;</div><div class="line">        return dispatch_barrier_async_f(dq, ctxt, func);</div><div class="line">    &#125;</div><div class="line">    dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT;</div><div class="line">    dc-&gt;dc_func = func;</div><div class="line">    dc-&gt;dc_ctxt = ctxt;</div><div class="line">    if (dq-&gt;do_targetq) &#123;</div><div class="line">        return _dispatch_async_f2(dq, dc);</div><div class="line">    &#125;</div><div class="line">    _dispatch_queue_push(dq, dc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见如果是串行队列 (dq_width = 1)，会调用 dispatch_barrier_async_f 函数处理，这个后文会有介绍。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。<br>把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_dispatch_queue_push</div><div class="line">└──_dispatch_trace_queue_push</div><div class="line">    └──_dispatch_queue_push</div><div class="line">        └──_dispatch_queue_push_slow</div><div class="line">            └──_dispatch_queue_push_list_slow2</div><div class="line">                └──_dispatch_wakeup</div><div class="line">                    └──dx_probe</div></pre></td></tr></table></figure></p>
<p>队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法。然后就是<strong>_dispatch_queue_wakeup_global-&gt;调用pthread-&gt;_dispatch_worker_thread 回调-&gt;执行任务-&gt;invoke</strong></p>
<p>2.3</p>
<p>##三、同步执行Synchronous Execution<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static void _dispatch_sync_f_slow(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;</div><div class="line">    _dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();</div><div class="line">    struct dispatch_sync_slow_s &#123;</div><div class="line">        DISPATCH_CONTINUATION_HEADER(sync_slow);</div><div class="line">    &#125; dss = &#123;</div><div class="line">        .do_vtable = (void*)DISPATCH_OBJ_SYNC_SLOW_BIT,</div><div class="line">        .dc_ctxt = (void*)sema,</div><div class="line">    &#125;;</div><div class="line">    _dispatch_queue_push(dq, (void *)&amp;dss);</div><div class="line"></div><div class="line">    _dispatch_thread_semaphore_wait(sema);</div><div class="line">    _dispatch_put_thread_semaphore(sema);</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##四、派发源Dispatch Sources</p>
<p>###4.1原理剖析<br>下图为dispatch_source_create这个API的代码,如何创建派发源的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ds = _dispatch_alloc(DISPATCH_VTABLE(source),</div><div class="line">            sizeof(struct dispatch_source_s));</div><div class="line">    _dispatch_queue_init((dispatch_queue_t)ds);</div><div class="line">    ds-&gt;dq_label = &quot;source&quot;;</div><div class="line">    ds-&gt;do_ref_cnt++; // the reference the manager queue holds</div><div class="line">    ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;</div><div class="line">    ds-&gt;do_targetq = &amp;_dispatch_mgr_q;</div></pre></td></tr></table></figure></p>
<p>从这段源码中我们可以知道：<br><strong>1.  猜想do是dispatchObject,是GCD的最基础类,虽然C语言中没有面向对象编程中的继承这个概念，但只要将dispatch_object_t结构体放在内存布局的开始处（作为“基类”），则实现了继承的概念</strong><br><strong>2.  ds-&gt;do_ref_cnt++即是dispatchSource的基类部分的引用计数+1</strong><br><strong>3. _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写,证明了即便 dispatch_source_create这个API不传入queue参数,也有root queue来分发</strong></p>
<p>###4.2GCD Timer并非没有弱点<br>于定时器的有效工作，有两个关键环节，一个是mgr queue，另一个是root queue。可以看到mgr queue只是负责事件监听和分发，可以理解是很轻量级的、不应该也不允许存在失效的；而root queue则负责从线程池分配线程执行任务，线程池的大小目前来看是255，并且有高低优先级之分。</p>
<p>我们创建的GCD Timer的优先级是继承自它的targetq的，而我们正常创建的queue所对应的root queue优先级是default，<strong>所以说如果存在大量高优先级的任务派发，或者255个线程都卡住了，那么GCD Timer是会被影响到的。</strong></p>
<p>##4.3、com.apple.libdispatch-manager<br>作为iOS开发，我们对com.apple.libdispatch-manager这个字符串应该很熟悉，比如在crash日志中看过，也会在断点调试时遇到——它基本都是紧随在主线程之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">static const struct dispatch_queue_vtable_s _dispatch_queue_mgr_vtable = &#123;</div><div class="line">    .do_type = DISPATCH_QUEUE_MGR_TYPE,</div><div class="line">    .do_kind = &quot;mgr-queue&quot;,</div><div class="line">    .do_invoke = _dispatch_mgr_invoke,</div><div class="line">    .do_debug = dispatch_queue_debug,</div><div class="line">    .do_probe = _dispatch_mgr_wakeup,</div><div class="line">&#125;;</div><div class="line">struct dispatch_queue_s _dispatch_mgr_q = &#123;</div><div class="line">    .do_vtable = &amp;_dispatch_queue_mgr_vtable,</div><div class="line">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</div><div class="line">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</div><div class="line">    .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</div><div class="line">    .do_targetq = &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_COUNT - 1],</div><div class="line"></div><div class="line">    .dq_label = &quot;com.apple.libdispatch-manager&quot;,</div><div class="line">    .dq_width = 1,</div><div class="line">    .dq_serialnum = 2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们发现，就连_dispatch_mgr_q都有它对应的do_targetq，从命名上来看，可以初步推断_dispatch_mgr_q要做的事情最终都会丢到它的targetq上来完成。<br>_dispatch_root_queues[DISPATCH_ROOT_QUEUE_COUNT - 1]即是序号3队列,用于内部任务的队列。<br>比如将定时器相关信息以及下一步要调用的方法封装成dispatch_continuation_t结构放到队列_dispatch_mgr_q中。<br>那么，_dispatch_mgr_q是做什么的呢？可以先简单直接地看看它通常在做什么：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-253a2863cbe73f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D05D2571-912B-44F8-99E3-359780AE3325.png"><br>可以看到，它通常都是没事干等事来。先来看看它怎么处于等事干的状态，也就是它怎么被创建出来并初始化完成的。</p>
<p>我们从上图调用栈可以看到线程入口是_dispatch_mgr_thread，它是作为_dispatch_mgr_q的.do_invoke的：<br>do_invoke的调用在整个libdispatch中，只有在元素出队的时候才会触发。<br>_dispatch_mgr_q从root queue出队时会进入等事干的状态，那么它是什么时候进队的？当我们要push任务块进入队列时会唤醒_dispatch_mgr_q队列并调用其.do_probe成员,_dispatch_mgr_q进行初始化配置进队并wakeup它的targetq。由于它的targetq是root queue，所以就会调用。<br>1.<strong>进队调用do_probe，出队调用do_invoke</strong><br>2.<strong>顺序是:push任务块-&gt;调用管理队列的do_probe成员-&gt;该成员负责唤醒管理队列并初始化-&gt;管理队列往root队列进队,即调用do_probe-&gt;_dispatch_queue_wakeup_global调用最底层全局线程-&gt;出队do_invoke-&gt;等待事件</strong></p>
<p>##五、GCD的尽头—线程池<br>// 老版本libdispatch的代码，新版本不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">static struct dispatch_queue_s _dispatch_root_queues[] = &#123;</div><div class="line">    &#123;</div><div class="line">        .do_vtable = &amp;_dispatch_queue_root_vtable,</div><div class="line">        .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</div><div class="line">        .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</div><div class="line">        .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</div><div class="line">        .do_ctxt = &amp;_dispatch_root_queue_contexts[0],</div><div class="line"></div><div class="line">        .dq_label = &quot;com.apple.root.low-priority&quot;,</div><div class="line">        .dq_running = 2,</div><div class="line">        .dq_width = UINT32_MAX,</div><div class="line">        .dq_serialnum = 4,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        // ... 省略部分代码</div><div class="line">        .dq_label = &quot;com.apple.root.low-overcommit-priority&quot;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        // ... 省略部分代码</div><div class="line">        .dq_label = &quot;com.apple.root.default-priority&quot;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        // ... 省略部分代码</div><div class="line">        .dq_label = &quot;com.apple.root.default-overcommit-priority&quot;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        // ... 省略部分代码</div><div class="line">        .dq_label = &quot;com.apple.root.high-priority&quot;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">                // ... 省略部分代码</div><div class="line">        .dq_label = &quot;com.apple.root.high-overcommit-priority&quot;,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到，在老版本的libdispatch中，_dispatch_mgr_q是取最高优先级的root queue来作为do_targetq的。而在新版本中，则是有专门为其服务的root queue：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static struct dispatch_queue_s _dispatch_mgr_root_queue = &#123;</div><div class="line">    .do_vtable = DISPATCH_VTABLE(queue_root),</div><div class="line">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</div><div class="line">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</div><div class="line">    .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</div><div class="line">    .do_ctxt = &amp;_dispatch_mgr_root_queue_context,</div><div class="line">    .dq_label = &quot;com.apple.root.libdispatch-manager&quot;,</div><div class="line">    .dq_running = 2,</div><div class="line">    .dq_width = DISPATCH_QUEUE_WIDTH_MAX,</div><div class="line">    .dq_serialnum = 3,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[iOS]Instagram/IGListKit实践谈]]></title>
      <url>http://chenmingjia.github.io/2016/11/10/unitsquare/</url>
      <content type="html"><![CDATA[<p>#简单介绍<br>IGListKit是Instagram推出的新的 UICollectionView 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。<br>github地址：<a href="https://github.com/Instagram/IGListKit" target="_blank" rel="external">https://github.com/Instagram/IGListKit</a><br>这个全新的控件一出来，我就赶快投入实践了一把。</p>
<p>先谈一谈我对这个控件的结论:这个框架设计的非常好，完美符合高内聚、低耦合。IGListKit 是一个很典型的使用 Objective-C 开发的，但却是个偏向使用 Swift 语言开发者的一个 UI 组件库。<br>使用过程也面临了一些疑惑，先谈一下使用收获:<br><img src="http://upload-images.jianshu.io/upload_images/712028-81c9910e9b51abfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2289D6DE-F316-4E7C-BD50-0B63BF33EEA8.png"></p>
<ol>
<li>它的优势在于flexible，比起原来的 UICollectionView ，在使用上更加灵活，在数据驱动上做的更好。</li>
<li>这个框架在fast上体现的还不够，但不妨碍我们自己进行下一步优化。</li>
</ol>
<p>#先看看IGListKit的结构</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-1bbefcabe3005a04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C49DDFF9-DBF9-4450-B407-91B319BBB240.png"><br>在原来的UICollectionViewController里的写法，我们一定都会实现UICollectionDataSource和UICollectionViewDelegate。<br>不过在IGListKit的实战过程中，你会发现似乎不用在ViewController中实现相关协议，取而代之的是SectionController来实现对应的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class DemoSectionController: IGListSectionController, IGListSectionType&#123;</div><div class="line">var object: DemoItem?</div><div class="line">func numberOfItems() -&gt; Int &#123;</div><div class="line">return 1</div><div class="line">&#125;</div><div class="line">func sizeForItem(at index: Int) -&gt; CGSize &#123;</div><div class="line">return CGSize(width: collectionContext!.containerSize.width, height: 55)</div><div class="line">&#125;</div><div class="line">func cellForItem(at index: Int) -&gt; UICollectionViewCell &#123;</div><div class="line">let cell = collectionContext!.dequeueReusableCell(of: LabelCell.self, for: self, at: index) as! LabelCell</div><div class="line">cell.label.text = object?.name</div><div class="line">return cell</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里直接取了官方的Demo里的其中一个SectionController作为例子。其实 UICollectionDataSource 和 UICollectionViewDelegate 都交给了 Adapter 这个适配器中。我们来看一下 IGAdapter.m 文件中的源码:<br>当我们为适配器绑定collectionView时，调用如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)setCollectionView:(IGListCollectionView *)collectionView &#123;</div><div class="line">if (_collectionView != collectionView || _collectionView.dataSource != self) &#123;</div><div class="line">_collectionView = collectionView;</div><div class="line">_collectionView.dataSource = self;</div><div class="line"></div><div class="line">[self updateCollectionViewDelegate];</div><div class="line">[self updateAfterPublicSettingsChange];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中self是指适配器对象。<br>接着适配器作为实现数据源协议的对象，我们来看一下它是怎么联系SectionController群的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">IGListSectionController&lt;IGListSectionType&gt; *sectionController = [self.sectionMap sectionControllerForSection:indexPath.section];</div><div class="line">_isDequeuingCell = YES;</div><div class="line">UICollectionViewCell *cell = [sectionController cellForItemAtIndex:indexPath.item];</div><div class="line">_isDequeuingCell = NO;</div><div class="line">[self mapCell:cell toSectionController:sectionController];</div><div class="line"></div><div class="line">return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到adapter通过遍历自己的sectionController的map来达到UICollectionView的数据源在cellForItem如何选择对应的sectionController。<br>坦白说，这样做，给人一种全新的思路，而且以后就算自己实现其实也并不复杂，可以参考其设计。</p>
<p>#WorkRange能做的事<br>什么是WorkRange？还是用Github的官方介绍说的更快，更清楚。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-408eae202f33d764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1A21C24B-A787-4B4C-8FA4-746BE27B4791.png"><br>大体就是说，我们可以指定左右的Working区间，干一些准备工作。<br>官网写的不多，只说了我们可以干事，具体干啥事，在我的个人实践中，我对它使用的理解是这样的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-3e47a6a8bccb28cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="84CE80C0-B909-4CF9-B43D-A1D4B52763ED.png"><br>更新数据源及预排版在ViewController进行，为Item设置layout属性。这样在SectionController中可以无需计算直接使用排版数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func updateItem(withItems items:Array&lt;CommentItem&gt;) &#123;</div><div class="line">/*</div><div class="line">假设我们在viewController中更新数据源，item为数据模型</div><div class="line">Items = [CommentItem(name: &quot;Mike&quot;, comment: &quot;&quot;),</div><div class="line">CommentItem(name: &quot;Chen&quot;, comment: &quot;&quot;),</div><div class="line">....]</div><div class="line">*/             </div><div class="line">commentGroup = CommentGroup(Items: Items)</div><div class="line"></div><div class="line">let queue = DispatchQueue(label: &quot;myBackgroundQueue&quot;)</div><div class="line">queue.async &#123;</div><div class="line">for item in Items &#123;</div><div class="line">let layout = CommentMainItemLayout(commentItem: item)</div><div class="line">item.layout = layout</div><div class="line">&#125;</div><div class="line">self.commentModels.append(self.commentGroup!)</div><div class="line"></div><div class="line">DispatchQueue.main.async &#123; [weak self] in</div><div class="line">self?.commentAdapter.performUpdates(animated: true, completion: nil)</div><div class="line">&#125;   </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而将预下载或者预渲染工作放在workRange中。<br><img src="http://upload-images.jianshu.io/upload_images/712028-cc4c4069276ec5ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="87F4E1DC-3664-48C9-9DBE-7E541D07DBEF.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func listAdapter(_ listAdapter: IGListAdapter, sectionControllerWillEnterWorkingRange sectionController: IGListSectionController) &#123;</div><div class="line">for  url: object.urls &#123;</div><div class="line">ImageCache.setImage(withUrl:url)     //如果需要预渲染，可自行设定</div><div class="line">&#125;      </div><div class="line">&#125;</div><div class="line"></div><div class="line">func listAdapter(_ listAdapter: IGListAdapter, sectionControllerDidExitWorkingRange sectionController: IGListSectionController) &#123;</div><div class="line">ImageCache.cancel()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#Display Delegate</p>
<p>我还没来得及用到Display Delegate，但我觉得它非常适合在显示文本的控件上使用异步绘制<br>我们先来看一看它的调用顺序</p>
<ol>
<li>func cellForItem(at index: Int) -&gt; UICollectionViewCell    </li>
<li>func listAdapterwillDisplay</li>
<li>func listAdapterdidEndDisplaying </li>
</ol>
<p>可以发现cellForItem在willDisplay前面，于是我会选择在cellForItem执行异步绘制。<br>在listAdapterdidEndDisplaying暂停异步绘制，最大程度上防止滑动速度过快，导致白白浪费去执行绘制任务。</p>
<p>#和想象不一样的数据驱动<br>当初看到github中官方给的图是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/712028-da92b9680abe5b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="09A72A4F-A716-4CAD-9BBE-5C4CA445F079.png"><br>我以为IGListKit里的数据驱动是类似双向绑定的结构，更新时不用手动显式的调用Update，可实际修改数据源模型，还是要显式调用<br> adapter.performUpdates(animated: true, completion: nil)<br>而这句代码对应的就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">Perform an update from the previous state of the data source. This is analagous to calling</div><div class="line">-[UICollectionView performBatchUpdates:completion:].</div><div class="line"></div><div class="line"></div><div class="line">open func performUpdates(animated: Bool, completion: IGListKit.IGListUpdaterCompletion? = nil)</div></pre></td></tr></table></figure></p>
<p>为什么称为Never Call呢？</p>
<p>#再来看一下Diff算法<br>简单来说这个算法就是计算tableView或者collectionView前后数据变化增删改移关系的一个算法，时间复杂度是O(n)，算是IGListKit的特色特点之一。<br>其实这个算法单独拿出来不只可以计算collectionView模型，稍加改造，也适用于其他模型或者文件的变化<br>使用的是Paul Heckel 的<a href="http://dl.acm.org/citation.cfm?id=359467&amp;dl=ACM&amp;coll=DL" target="_blank" rel="external">A technique for isolating differences between files</a> 的算法，这份paper是收费。<br>不过这并不妨碍我们直接看源码，我们可以看一下IGListDiff.mm文件,该算法使用C++来编写。<br>主要是通过hashtable和新旧的两个数组结构：<br><img src="http://upload-images.jianshu.io/upload_images/712028-71cfbf10af55361d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FB5A6940-3E6D-481A-9211-16127D3C767B.png"><br>用简单的例子来说，这里我模拟的是从假设原来的  1，2，4，1的旧数据模型到新的1，2，3，5的数据模型的变化过程，假想成Swift中代码，应该是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let oldModel = [</div><div class="line">Num(id: 1, name: &quot;1&quot;),</div><div class="line">Num(id: 2, name: &quot;2&quot;),</div><div class="line">Num(id: 3, name: &quot;4&quot;),</div><div class="line">Num(id: 4, name: &quot;1&quot;),</div><div class="line">]</div><div class="line">let newModel = [</div><div class="line">Num(id: 1, name: &quot;1&quot;),</div><div class="line">Num(id: 2, name: &quot;2&quot;),</div><div class="line">Num(id: 3, name: &quot;3&quot;),</div><div class="line">Num(id: 4, name: &quot;5&quot;),</div><div class="line">]</div><div class="line">let result = IGListDiffPaths(0, 0, from, to, .equality).forBatchUpdates()</div><div class="line">tableView.beginUpdates()</div><div class="line">tableView.deleteRows(at: result.deletes, with: .fade)</div><div class="line">tableView.insertRows(at: result.inserts, with: .fade)</div><div class="line">for move in result.moves &#123;</div><div class="line">tableView.moveRow(at: move.from, to: move.to)</div><div class="line">&#125;</div><div class="line">tableView.endUpdates()</div></pre></td></tr></table></figure></p>
<p>首先oldIndexs是一个栈的结构，过程是先遍历新数组，将数组里模型的id对应的hash值作为key，找到对应的Num成员对象（实际代码中为entry，可以理解为一种抽象）的oldIndexs栈存入NSNotFound。<br>再遍历旧数组，拿例子来说，就是将数组里模型的id  对应的hash值作为key，找到对应的Num成员对象里的oldIndexs栈增加旧数组的下标值。<br>如果是新增加的，那么在hashtable中key对应的value存入的Num成员对象就是notfound。<br>这样算法如图使用的数据结构（已简化，实际稍复杂些），可以绑定新旧数组的成员的对应关系，包括成员间的移动增加删除修改关系，对于像TableView或者CollectionView非常适合不过。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[译]使用幽灵类型的Measurements和Units ，第四部分]]></title>
      <url>http://chenmingjia.github.io/2016/10/18/unitsquare/</url>
      <content type="html"><![CDATA[<p>原文链接=<a href="https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/" target="_blank" rel="external">https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/</a><br>作者=Ole Begemann<br>译者=与狼同行</p>
<!--此处开始正文-->
<p>本系列其他文章：</p>
<p>(1) <a href="http://oleb.net/blog/2016/07/measurements-and-units/" target="_blank" rel="external">Measurements 和 Units 概览</a><br>(2) <a href="http://oleb.net/blog/2016/07/unitproduct/" target="_blank" rel="external">乘法和除法</a><br>(3) <a href="http://swift.gg/2016/09/29/unitsquare/" target="_blank" rel="external">内容提炼</a><br>(4) 幽灵类型(本文)</p>
<p>我之前撰写了关于标准库里新的度量值的短系列，此文是该系列的额外之作。虽然我很喜欢苹果的 API ，但我觉得探索同一问题的不同解决方案也很有意思。特别是这个问题，纯 Swift 设计是否能优于苹果的接口呢，因为苹果的接口考虑了 Objective-C 的<a href="https://lists.swift.org/pipermail/swift-corelibs-dev/Week-of-Mon-20160808/000864.html" target="_blank" rel="external">兼容性问题</a>。</p>
<a id="more"></a>
<h2 id="苹果的设计"><a href="#苹果的设计" class="headerlink" title="苹果的设计"></a>苹果的设计</h2><p>在苹果的 API 中，开发者主要使用的数据类型是<a href="https://developer.apple.com/reference/foundation/nsmeasurement" target="_blank" rel="external">度量值 <code>Measurement</code> 类型</a>，它包含一个浮点数  <code>value</code> 和用于测值的单位 <code>unit</code> ，并基于单位类型使用了泛型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Measurement&lt;UnitType: Unit&gt; &#123;</div><div class="line">let unit: UnitType</div><div class="line">var value: Double</div><div class="line">&#125;</div><div class="line"></div><div class="line">let length = Measurement(value: 5， unit: UnitLength.meters)</div><div class="line">// 长度表现为一个 Measurement&lt;UnitLength&gt;</div></pre></td></tr></table></figure>
<p>Measurement 被视为<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md" target="_blank" rel="external">值类型</a>——它在 Objective-C 中是类，在 Swift 中是结构体。<br>在单位族（Unit Family）中，比如说长度或时长，被建模为类层次结构中的类型:  <a href="https://developer.apple.com/reference/foundation/nsunit" target="_blank" rel="external">Unit</a> &gt; <a href="https://developer.apple.com/reference/foundation/nsdimension" target="_blank" rel="external">Dimension</a> &gt; <a href="https://developer.apple.com/reference/foundation/nsunitlength" target="_blank" rel="external">UnitLength</a> 、 <a href="https://developer.apple.com/reference/foundation/nsunitduration" target="_blank" rel="external">UnitDuration</a>等等。具体的类型如米、千克，分别是它们单位族类的实例。每一个单位都是由单位的符号（如「kg」）和一个 <a href="https://developer.apple.com/reference/foundation/unitconverter" target="_blank" rel="external">单元转换</a>对象组成，该对象通过编码指令来使单位转化为该单位族的基本单位。</p>
<h2 id="幽灵类型"><a href="#幽灵类型" class="headerlink" title="幽灵类型"></a>幽灵类型</h2><p>如果我们将具体的单位视为一个类型而不是实例呢？假设有一些类型名为米（Meters）、千米（Kilometers），或者英里（Miles），我们可以设计一个泛型的 <code>Measurement</code> 类型，它只有一个存储属性来存放量值，该量值的单位可以被完整编码在自身类型中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct MyMeasurement&lt;UnitType: MyUnit&gt; &#123;</div><div class="line">var value: Double</div><div class="line"></div><div class="line">init(_ value: Double) &#123;</div><div class="line">self.value = value</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let length = MyMeasurement&lt;Meters&gt;(5)</div><div class="line">// length is a MyMeasurement&lt;Meters&gt;</div></pre></td></tr></table></figure></p>
<p>现在我们再次审视两种方式的不同之处，苹果的设计是让单位族 <code>length</code>作为 <code>Measurement</code> 的参数，让具体的单位 米 作为该值的一部分。而我的设计是让具体的单位 米 成为泛型参数。<br><code>MyMeasurement</code> 也能被称为<a href="https://wiki.haskell.org/Phantom_type" target="_blank" rel="external">幽灵类型</a>，因为泛型参数 UnitType 没有在类型声明中出现。它的用途仅仅是用于相互区分类似 <code>MyMeasurement &lt;Meters&gt;</code> 和 <code>MyMeasurement &lt;Kilometers&gt;</code> 这样的类型，这样它们就无法互相替换。<br>我们之后将看看这样设计是否真的有用，因为你可能会争辩，用米的度量值应当能与用千米的度量值互相转换。想了解更多关于 Swift 中幽灵类型的例子，可以看 <a href="https://www.objc.io/blog/2014/12/29/functional-snippet-13-phantom-types/" target="_blank" rel="external">objc.org</a> 的文章或 <a href="https://realm.io/news/swift-summit-johannes-weiss-the-type-system-is-your-friend/" target="_blank" rel="external">Johannes Weiß</a> 的谈话。Swift标准库也在使用幽灵类型，例如 <a href="https://developer.apple.com/reference/swift/unsafepointer" target="_blank" rel="external">UnsafePointer <memory></memory></a> 。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我的方法最明显的好处是比使用度量值数据类型在大小上要小 50 % ，因为对单位实例的引用不是必要的。（单位实例自身是被所有那个单位的 Measurement 类所共用的，例如 5 米 和 10 米 两个度量值引用的是同一个单位实例。）但大小尺寸上的节省优势会被潜在更大的代码量所抵消，因为编译器会为泛型类型和使用该类型的函数产生更多的特化。</p>
<p>由于 Unit 在苹果的 API 中为引用类型，将测量值传给函数也会带来 retain 和 release 的开销。这两个因素对一个传统 App 来说都不是很重要，我也没有展开进一步的研究，在探索这些想法的时候，它们对我来说无关紧要。</p>
<h2 id="具体的设计"><a href="#具体的设计" class="headerlink" title="具体的设计"></a>具体的设计</h2><p>我们现在具体说一下如何在这个系统中定义单位，所有的单位都被封装到不同的单位族中，比如长度、温度、时长。我们开始为单位族定义一个协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// 表现为一种物理数值 或者 可以认为是 “ 单位之族 ”</div><div class="line">/// 例如: 长度， 温度， 速率.</div><div class="line">protocol UnitFamily &#123;</div><div class="line">associatedtype BaseUnit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如苹果API中，每个单位族都会定义一个基础单位，它用于同一单位族的不同类型间的相互转换，例如长度单位族的基础单位是米。我们在 <code>UnitFamily</code> 协议中，把该基础单位定义为一个关联类型，这会有一个好处，基础单位会在这个类型系统中被编码，在 Foundation 库中，基础单位必须被单独记录以使得其他人用自定义的单位来扩展这个系统。</p>
<p>下一步是定义 <code>MyUnit</code> 协议以塑造具体的单位，这些单位在苹果的设计中会被定义为单位族类型的一个实例。（这里我使用 My 作为前缀来避免和苹果类型的命名冲突）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/// 表现为度量值的单位</div><div class="line">/// 例如: 米， 公里， 英里， 秒， 小时， 摄氏度.</div><div class="line">protocol MyUnit &#123;</div><div class="line">associatedtype Family: UnitFamily</div><div class="line"></div><div class="line">static var symbol: String &#123; get &#125;</div><div class="line">static var converter: UnitConverter &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单位通过关联类型的方式来进行声明其所属的单位族。用静态属性来保存它的符号（比如米的符号是 m ，磅的符号是 lbs ）和它的单位转化器，转化器描述了如何将该单位转化为该族的基础单位。假如说长度单位族的基础单位是米，那么公里单位的转化器应该就是 <code>UnitConverterLinear(coefficient: 1000)</code>。基础单位自身的转化器系数应该为1。我这里从 Foundation 库中借用了<a href="https://developer.apple.com/reference/foundation/unitconverter" target="_blank" rel="external">UnitConverter</a> 类型。 Foundation 库将没有维度单位的 Unit 和有维度单位的 Dimension 进行了区分。简单起见，我们就不做这些事了，我们所有的单位都是有维度的。<br>基础单位也必须是一个单位类型，这样想当然没错，理想来说在 UnitFamily 协议中的 BaseUnit 应当有一个对应的基础单位约束，那就是 MyUnit 。不过遗憾的是，这样会使得两个协议之间产生循环引用，这样在Swift中肯定是不被许可的。话虽如此说，但即便没有约束，一切也能工作顺利。</p>
<h2 id="遵守协议"><a href="#遵守协议" class="headerlink" title="遵守协议"></a>遵守协议</h2><p>现在来为协议添加具体的实现。我这里展示一下长度、速度和时长的例子，每个都设置几个单位，再添加更多的单位和单位族也没什么意义。我选择用枚举来作为类型的结构，因为无例枚举不能被实例化，这对我们来说非常完美，因为我们只对类型感兴趣，而不是对类型的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">enum Length: UnitFamily &#123;</div><div class="line">typealias BaseUnit = Meters</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Meters: MyUnit &#123;</div><div class="line">typealias Family = Length</div><div class="line">static let symbol = &quot;m&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Kilometers: MyUnit &#123;</div><div class="line">typealias Family = Length</div><div class="line">static let symbol = &quot;km&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1000)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - Duration</div><div class="line">enum Duration: UnitFamily &#123;</div><div class="line">typealias BaseUnit = Seconds</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Seconds: MyUnit &#123;</div><div class="line">typealias Family = Duration</div><div class="line">static let symbol = &quot;s&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Minutes: MyUnit &#123;</div><div class="line">typealias Family = Duration</div><div class="line">static let symbol = &quot;min&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 60)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Hours: MyUnit &#123;</div><div class="line">typealias Family = Duration</div><div class="line">static let symbol = &quot;hr&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 3600)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - Speed</div><div class="line">enum Speed: UnitFamily &#123;</div><div class="line">typealias BaseUnit = MetersPerSecond</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum MetersPerSecond: MyUnit &#123;</div><div class="line">typealias Family = Speed</div><div class="line">static let symbol = &quot;m/s&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum KilometersPerHour: MyUnit &#123;</div><div class="line">typealias Family = Speed</div><div class="line">static let symbol = &quot;km/h&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1.0/3.6)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="转换度量值"><a href="#转换度量值" class="headerlink" title="转换度量值"></a>转换度量值</h2><p>现在我们已经可以用不同的单位来表示度量值，接着我们需要让它们相互转换。<code>converted(to:)</code> 方法传入一个目标单位类型的参数并通过单位转换器返回那个单位新的度量值。注意这句约束<code>TargetUnit.Family == UnitType.Family</code>，它限制了转换只能适用于同单位族，编译器不会让你把<code>Meters</code>转换为<code>Seconds</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">extension MyMeasurement &#123;</div><div class="line">/// Converts `self` to a measurement that has another unit of the same family.</div><div class="line">func converted&lt;TargetUnit&gt;(to target: TargetUnit.Type) -&gt; MyMeasurement&lt;TargetUnit&gt;</div><div class="line">where TargetUnit: MyUnit， TargetUnit.Family == UnitType.Family</div><div class="line">&#123;</div><div class="line">let valueInBaseUnit = UnitType.converter.baseUnitValue(fromValue: value)</div><div class="line">let valueInTargetUnit = TargetUnit.converter.value(fromBaseUnitValue: valueInBaseUnit)</div><div class="line">return MyMeasurement&lt;TargetUnit&gt;(valueInTargetUnit)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来为 <code>MyMeasurement</code> 添加一些方便的功能，遵守<code>CustomStringConvertible</code>是一个输出调试的良好方案，并通过遵守 <code>ExpressibleByIntegerLiteral</code> 和 <code>ExpressibleByFloatLiteral</code> 协议使得通过字面量创建新的度量值变得更加轻松愉快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">extension MyMeasurement: CustomStringConvertible &#123;</div><div class="line">var description: String &#123;</div><div class="line">return &quot;\(value) \(UnitType.symbol)&quot;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension MyMeasurement: ExpressibleByIntegerLiteral &#123;</div><div class="line">init(integerLiteral value: IntegerLiteralType) &#123;</div><div class="line">self.value = Double(value)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension MyMeasurement: ExpressibleByFloatLiteral &#123;</div><div class="line">init(floatLiteral value: FloatLiteralType) &#123;</div><div class="line">self.value = value</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>现在我们开始创造一些度量值并把它们转换为其他单位，应用字面量的语法来表达对象创建非常不错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let fiveMeters: MyMeasurement&lt;Meters&gt; = 5</div><div class="line">// → 5.0 m</div><div class="line">let threeKilometers: MyMeasurement&lt;Kilometers&gt; = 3</div><div class="line">// → 3.0 km</div><div class="line">threeKilometers.converted(to: Meters.self)</div><div class="line">// → 3000.0 m</div><div class="line">threeKilometers.converted(to: Seconds.self)</div><div class="line">// error: &apos;Family&apos; (aka &apos;Length&apos;) is not convertible to &apos;Family&apos; (aka &apos;Duration&apos;) (as expected)</div></pre></td></tr></table></figure>
<p>我们再来看看把度量值作为函数参数会怎么样？看一下这个假想的<code>delay</code>函数，它以时长和一个闭包作为参数，并在具体时长后执行闭包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func delay(after duration: MyMeasurement&lt;Seconds&gt;， block: () -&gt; ()) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数需要以秒为单位的度量值，如果你传入了毫秒作为参数，你必须负责转化值。以 <code>TimeInterval</code> 作为参数可以具有类型安全的优势，编译器不会允许你传入 <code>MyMeasurement&lt;Milliseconds&gt;</code> 作参数，但这样做会比我们使用 <code>Measurement&lt;UnitDuration&gt;</code> 要大大降低灵活性，使用后者将会允许我们传入任意的时长单位。</p>
<p>我们通过基于单位类型将函数泛型化实现它(并且附上约束，它的单位族必须为时长)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func delay&lt;Time&gt;(after duration: MyMeasurement&lt;Time&gt;， block: () -&gt; ())</div><div class="line">where Time: MyUnit， Time.Family == Duration</div><div class="line">&#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法会有用，但会大大降低函数签名的可读性，即便是在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md" target="_blank" rel="external"> Where 子句的位置被转移</a>之后。</p>
<p>但就这一条理由来说，苹果将单位设为实例而不是类型的做法可能更为实用，更有意义。毕竟，米和公里只是同一东西的不同说法而已。但探索这个问题并不是很有意义，我们还是先继续。</p>
<h2 id="加法和标量乘法"><a href="#加法和标量乘法" class="headerlink" title="加法和标量乘法"></a>加法和标量乘法</h2><p>有时候我们需要把同样单位族的两个度量值作加法，即便他们有不同单位。通过使用泛型来重载 <code>+</code> 运算符方法就会容易，并且在习惯上我们会把右边的值转化为左边值得单位，并返回基于那个单位的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func + &lt;Unit1， Unit2&gt; (lhs: MyMeasurement&lt;Unit1&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Unit1&gt;</div><div class="line">where Unit1: MyUnit， Unit2: MyUnit， Unit1.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let rhsConverted = rhs.converted(to: Unit1.self)</div><div class="line">return MyMeasurement(lhs.value + rhsConverted.value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fiveMeters + threeKilometers</div><div class="line">// → 3005.0 m</div><div class="line">threeKilometers + fiveMeters</div><div class="line">// → 3.005 km</div></pre></td></tr></table></figure>
<p>我们再来注意一下这个约束 <code>Unit1.Family == Unit2.Family</code> ，它防止秒和米相加。</p>
<p>标量乘法就更容易实现了，因为没有单位转换参与。我们简单的把值相乘并创造一个新的度量值，两个重载方法被用于 <code>a * b</code> 和 <code>b * a</code> 两种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func * &lt;UnitType&gt; (measurement: MyMeasurement&lt;UnitType&gt;， scalar: Double) -&gt; MyMeasurement&lt;UnitType&gt; &#123;</div><div class="line">var result = measurement</div><div class="line">result.value *= scalar</div><div class="line">return result</div><div class="line">&#125;</div><div class="line"></div><div class="line">func * &lt;UnitType&gt; (scalar: Double， measurement: MyMeasurement&lt;UnitType&gt;) -&gt; MyMeasurement&lt;UnitType&gt; &#123;</div><div class="line">return measurement * scalar</div><div class="line">&#125;</div><div class="line"></div><div class="line">threeKilometers * 2</div><div class="line">// → 6.0 km</div><div class="line">let twoSeconds: MyMeasurement&lt;Seconds&gt; = 2</div><div class="line">60 * twoSeconds</div><div class="line">// → 120.0 s</div></pre></td></tr></table></figure>
<p>如果你记得这个系列的<a href="https://oleb.net/blog/2016/07/unitproduct/" target="_blank" rel="external">第二部分</a>，我最初的目的是想让单位之间可以被设计得相互依赖，例如  速度 = 路程 / 时间  或者 能量 = 功率 × 时间 。为了做到这些，我要介绍一个协议叫做 <code>UnitProduct</code>，通过遵守该协议和命名作为关联类型的因子，这样单位族可以表示其因子。</p>
<p>我们又做同样的事，但这次展示不同单位的关系而不是单位族。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// Describes this relation between units:</div><div class="line">/// Product = Factor1 * Factor2</div><div class="line">protocol Product: MyUnit &#123;</div><div class="line">associatedtype Factor1: MyUnit</div><div class="line">associatedtype Factor2: MyUnit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下这样一个简单的协议足以描述乘法性和除法性关系，因为 <code>a = b × c</code> 等价于 <code>b = a / c</code>。选择结果是随意的，这样无论怎么选都会让这个关系看上去不自然。举例来说，假如我们想表示 速度 = 路程 / 时间，我们就得也把它重写为 路程 = 速度 × 时间 。<br>下一步来实现实际计算，即重载作用于遵守协议的类型的乘法和除法运算符方法。我们需要四个变量：<br><code>a = b × c</code><br>泛型约束让它看起来更加复杂了，对于任意遵守 <code>Product</code> 协议的 <code>Result</code> 类型，这个重载方法定义两个度量值的乘法，这两个度量值的单位 <code>Unit1</code> 和 <code>Unit2</code> 有着和 <code>Result</code>的 <code>Result.Factor1</code>和 <code>Result.Factor2</code>同样的单位族。而结果是通过将度量值各自转化为 <code>Result.Factor1</code> 和 <code>Result.Factor2</code> ，然后相乘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func * &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Unit1&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Result&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let left = lhs.converted(to: Result.Factor1.self)</div><div class="line">let right = rhs.converted(to: Result.Factor2.self)</div><div class="line">return MyMeasurement(left.value * right.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>a = c × b</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func * &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Unit2&gt;， rhs: MyMeasurement&lt;Unit1&gt;) -&gt; MyMeasurement&lt;Result&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">return rhs * lhs</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这和先前的函数不完全类似，它将 lhs和 rhs 置换了。实现方式仅仅是转发给其他重载方法。</p>
<p><code>b = a / c   and  c = a / b</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func / &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Result&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Unit1&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let right = rhs.converted(to: Result.Factor2.self)</div><div class="line">return MyMeasurement(lhs.value / right.value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func / &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Result&gt;， rhs: MyMeasurement&lt;Unit1&gt;) -&gt; MyMeasurement&lt;Unit2&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let right = rhs.converted(to: Result.Factor1.self)</div><div class="line">return MyMeasurement(lhs.value / right.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的方式，不过泛型参数的位置发生了变化。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>现在它终于可以表示关系 路程 = 速度 × 时间（即 速度 = 路程 / 时间）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extension Meters: Product &#123;</div><div class="line">typealias Factor1 = MetersPerSecond</div><div class="line">typealias Factor2 = Seconds</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可以这样用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let tenMeters: MyMeasurement&lt;Meters&gt; = 10</div><div class="line">let fourSeconds: MyMeasurement&lt;Seconds&gt; = 4</div><div class="line">let speed: MyMeasurement&lt;MetersPerSecond&gt; = tenMeters / fourSeconds</div><div class="line">// → 2.5 m/s</div><div class="line"></div><div class="line">let thirtyKilometersPerHour: MyMeasurement&lt;KilometersPerHour&gt; = 30</div><div class="line">let twoHours: MyMeasurement&lt;Hours&gt; = 2</div><div class="line">let tripLength: MyMeasurement&lt;Meters&gt; = thirtyKilometersPerHour * twoHours</div><div class="line">// → 60000.0 m</div><div class="line">tripLength.converted(to: Kilometers.self)</div><div class="line">// → 60.0 km</div></pre></td></tr></table></figure>
<p>它的工作效果不错，但是有两个明显的缺点。第一个是目前的编译器无法推断出自动计算的返回类型，我不知道是否今后的编译器可以解决这个问题，也许我可以通过在函数中设置更好的泛型约束的方式提供一些帮助，但是尝试之后，依然没能解决问题。<br>第二点是参数的单位需要有正确的单位族，返回类型的单位会被使用 <code>Product</code> 协议的具体单位所限制。因此类似 <code>let tripLength: MyMeasurement&lt;Kilometers&gt; = ...</code> 并不会起作用，你必须先提供以米形式的结果，然后再把它转换。这是一个非常大的限制。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>忽略这个设计的缺陷（确实存在），你得注意不止一行可执行代码需要为类型系统增加数学关系！仅仅通过添加协议一致（即定义两个关联类型），我们就可以从字面上把任务 1 meter = 1 m/s × 1 s 添加给编译器的“真理”池。但如果你要添加其他数学关系（比如1 J = 1 W × 1 s），那么我们就必须再添加一个协议一致。<br>我觉得这种写法非常吸引我。但尽管如此，我不认为这个基于幽灵类型的 API 优于苹果基础库中的 API，基于单位族而不是单位的度量值其实只会更加有意义。</p>
]]></content>
    </entry>
    
  
  
</search>
