<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[[iOS]并发编程录--锁]]></title>
      <url>http://chenmingjia.github.io/2016/11/16/unitsquare/</url>
      <content type="html"><![CDATA[<p>#一、锁的基本介绍</p>
<p>###1.1为什么需要锁？？<br><strong>(1)解决资源共享问题</strong><br>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-d4e125a1d1345748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C2A1576F-C030-4683-B461-132A8D7B45D5.png"></p>
<p>这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>
<p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（乱序执行）。<br><strong>(2)并发编程为什么难？什么是重排序？</strong><br>重排序分为两类：编译期重排序和运行期重排序(乱序执行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">假设x,y初始都为0,请问r1、r2最终为什么会是0？</div><div class="line">Thread1 ：</div><div class="line">x=1；</div><div class="line">r1=y；</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Thread2 ：</div><div class="line">y=1；</div><div class="line">r2=x；</div></pre></td></tr></table></figure>
<p>这是并发编程非常经典一个问题。在了解乱序执行之前，大多数我们一定会认为答案一定在0,1、1,0、1,1这三者之间。事实上,这题目还肯定存在0，0的结果。<br>我们总是想当然的认为x=1一定会发生在r1=y之前，事实上，编译器会乱序执行，因为它认为在当前线程打乱顺序是无所谓的。但其实它对另外一个线程同时使用的变量来说非常重要。</p>
<p><strong>类似的情况还有很多,现代微处理器的设计使用了数据缓存、指令重叠执行和内存乱序访问。</strong><br><strong>如果没有做好共享数据的同步，很容易出现各种看似诡异的问题。</strong></p>
<p>###1.2锁的各个性能<br><img src="http://upload-images.jianshu.io/upload_images/712028-650341f5957b84f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C2FA214E-1254-4F09-9753-FA444D65A474.png"><br>看到除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的。有消息称，苹果在新系统中已经优化了 pthread_mutex 的性能，所以它看上去和 OSSpinLock 差距并没有那么大了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-6c504a97e51bb27a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CA403DFB-1C01-468C-B000-9020CEB866F9.png"><br>上图是常规的锁操作性能测试(iOS7.0SDK，iPhone6模拟器，Yosemite 10.10.5)，垂直方向表示耗时，单位是秒，总耗时越小越好，水平方向表示不同类型锁的锁操作，具体又分为两部分，左边的常规lock操作(比如NSLock)或者读read操作(比如ANReadWriteLock)，右边则是写write操作，图上仅有ANReadWriteLock和ANRecursiveRWLock支持，其它不支持的则默认为0，图上看出，单从性能表现，原子操作是表现最佳的(0.057412秒)，@synchronized则是最耗时的(1.753565秒) (<a href="https://github.com/SpringOx/ANLock" target="_blank" rel="external">测试代码</a>)<br>正如前文所述，不同方案各有侧重，适用于不用的场景，不能唯性能论高低：<br>原子操作虽然性能很好，但仅限于set/get，比如对列表的插入移除操作需要做同步则无能为力，支持不到，所以适用于一些实例成员变量的读写同步；</p>
<p>##二、互斥锁mutex</p>
<p>###2.1基本概念<br>互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-6394324cd13e9598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AD1300C2-2DF2-43D8-99BE-7EA25E6CDAA7.png"><br>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。<br>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。</p>
<p>###2.2实际使用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-c2d5d99ae4fb9cfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="67E8D3CF-DCA8-443C-A889-3B2BBB75F516.png"></p>
<p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</p>
<p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p>
<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。</p>
<p>###2.3pthread_mutex的实现与NSLock<br>互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。</p>
<p>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。</p>
<p>另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p>
<hr>
<p>NSLock、NSRecursiveLock是典型的面向对象的锁，即同步锁类，遵循Objective-C的NSLocking协议接口，前者支持tryLock，后者支持递归(可重入)；<br>它的实现非常简单，通过宏，定义了lock方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define    MLOCK \</div><div class="line">- (void) lock\</div><div class="line">&#123;\</div><div class="line">int err = pthread_mutex_lock(&amp;_mutex);\</div><div class="line">// 错误处理 ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NSLock只是在内部封装了一个pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部pthread_mutex<br>互斥锁的类型不同。通过宏定义，可以简化方法的定义。<br>NSLock比pthread_mutex略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p>
<p>###2.4性能与使用场景<br>pthread_mutex是pthread经典的基于互斥量机制的同步锁，特性、性能以及稳定各方面都已被大量项目所验证，也是比较推荐作为常规同步锁首选</p>
<p>###三、自旋锁OSSpinLock<br>iOS/MacOS自有的自旋锁，其特点是线程等待取锁时不进内核，线程因此不挂起，直接保持空转，这使得它的锁操作开销降得很低，OSSpinLock是不支持递归的；</p>
<p>###3.1基本使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">OSSpinLockLock(&amp;theLock);</div><div class="line">sleep(1);</div><div class="line">NSLog(@&quot;需要线程同步的操作2&quot;);</div><div class="line">OSSpinLockUnlock(&amp;theLock);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>###3.2基本原理<br>自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">do &#123; </div><div class="line">Acquire Lock Critical section // </div><div class="line">临界区 Release Lock </div><div class="line">Reminder section  // 不需要锁保护的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。</p>
<p>自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁</div><div class="line">do &#123;</div><div class="line">while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 </div><div class="line">lock = true; // 挂上锁，这样别的线程就无法获得锁 </div><div class="line">Critical section // 临界区           </div><div class="line">lock = false; // 相当于释放锁，这样别的线程可以进入临界区 </div><div class="line">Reminder section // 不需要锁保护的代码 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释写得很清楚，就不再逐行分析了。可惜这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。</p>
<p>###3.3原子操作<br>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。</p>
<p>然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。</p>
<p>这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁</div><div class="line">do &#123;</div><div class="line">while(test_and_set(&amp;lock); // test_and_set 是一个原子操作</div><div class="line">Critical section // 临界区</div><div class="line">lock = false; // 相当于释放锁，这样别的线程可以进入临界区 </div><div class="line">Reminder section // 不需要锁保护的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###3.4致命缺点<br>(1)<strong>安全问题，优先级反转</strong><br>(2)<strong>如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。</strong></p>
<p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p>
<p>得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段；‘</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-8dcfdbf5b986a3b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![F8D8D08F-F1C3-4612-8800-716B0F3C0BFB.png](http://upload-images.jianshu.io/upload_images/712028-4c440040f26ca1bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p>
<p>###3.1什么是优先级反转？<br>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-8f6def0e5ff339e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="672BC89F-8108-4AF9-A0B4-ED61D347507E.png"><br>从中得到的教训是，使用不同优先级听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p>
<p>###为什么其他锁不会发生优先级反转？</p>
<p>#3.6使用场景<br><strong>自旋锁适合短时间的操作，加锁性能最快，但不能使用不同优先级。</strong></p>
<p>##四、读写锁</p>
<p>###4.1</p>
<p>###4.2</p>
<p>###4.3性能<br>读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响；以pthread_mutex和ANRecursiveRWLock为例，假设mutex的lock耗时为lk，则rw的read lock耗时为2.7lk(从性能测试图表数据得出)，read操作耗时为rd，1000次的多线程接口访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 = 1000*lk + 1000*rd</div><div class="line">rw总耗时 = 1000*2.7*lk + 1000/c*rd</div></pre></td></tr></table></figure></p>
<p>其中c表示应用的并发数，根据开发文档和技术资料，iOS第二条线程起stack为512KB，而单个应用useable memory size在50MB以内，即c&lt;=100；<br>假设线程数取中值c=50(严格来说，线程数不等于冲突计数，冲突计数很可能会比线程数小得多，线程同步运行不代表就即刻会发生冲突)，当 mutex总耗时 &gt; rw总耗时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 &gt; rw总耗时  =》 50*lk + 50*rd &gt; 50*2.7lk + rd  =》 49*rd &gt; 85*lk   =》 rd &gt; 1.73*lk</div></pre></td></tr></table></figure></p>
<p>可以看出，只要read操作耗时超过锁操作耗时的1.7倍(这其实很容易达到的)，读写锁的性能就会占优势<br>假设线程数c=2(如上述，这里是假设了两个线程之间是竞争了，发生冲突，实际未必)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 &gt; rw总耗时  =》 2*lk + 2*rd &gt; 5.4*lk + rd  =》 rd &gt; 3.4lk</div></pre></td></tr></table></figure></p>
<p>即使只有两个并发线程，只要read操作耗时超过锁操作耗时的3.4倍，读写锁的性能还会占优势<br>假设线程数c=1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutex总耗时 &gt; rw总耗时  =》0 &gt; 1.7lk</div></pre></td></tr></table></figure></p>
<p>这显然不成立，说明当单个线程的时候，rw的性能不可能有优势。这也好理解，这时候的mutex和rw的读操作都相当完全同步，不论是mutex还是rw，性能完全取决于锁操作本身，而rw在锁操作耗时上就不占优势，所以mutex总耗时总是要小于rw总耗时的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-653a089bebdf30c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![B9FAA079-DFA3-4620-B06D-B0597C29F8CF.png](http://upload-images.jianshu.io/upload_images/712028-23114f92b41d5697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-1d47726c9b8f58f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D0D6390E-3A1E-46D1-9A0A-055E853CA235.png"><br>上图是mutex锁和rw锁read操作的耗时测试用例，下图为测试结果，read操作设置为100微秒，mutex锁的总耗时是rw锁的5倍多，read操作的耗时远比锁操作大许多(2k倍)，根据上述恒等式计算可以得出实际的冲突计数c=5</p>
<p>###五、信号量</p>
<p>###5.1基本概念</p>
<p>###5.2基本原理<br>dispatch_semaphore的性能表现出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制，是否适用于常规同步锁有待实践验证。不做推荐<br>信号量dispatch_semaphore_t的实现原理，它最终会调用到sem_wait<br>方法，这个方法在 glibc 中被实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int sem_wait (sem_t *sem) &#123;</div><div class="line">int *futex = (int *) sem;</div><div class="line">if (atomic_decrement_if_positive (futex) &gt; 0)</div><div class="line">return 0;</div><div class="line">int err = lll_futex_wait (futex, 0);</div><div class="line">return -1;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在lll_futex_wait<br>函数中实现，<strong>lll</strong> 是 low level lock 的简称。这个函数通过汇编代码实现，调用到SYS_futex<br>这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。<br>主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。<br>可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</p>
<p>###5.3缺点<br>在时间较短的操作，没有自旋锁高效，会有上下文切换的成本。</p>
<p>###5.4优点<br>相对</p>
<p>#六、条件锁</p>
<p>###6.1基本概念<br>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</p>
<p>###6.2基本使用<br>很多介绍pthread_cond_t的文章都会提到，它需要与互斥锁配合使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void consumer () &#123; // 消费者</div><div class="line">pthread_mutex_lock(&amp;mutex);</div><div class="line">while (data == NULL) &#123;</div><div class="line">pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据</div><div class="line">&#125;</div><div class="line">// --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓</div><div class="line">// temp = data;</div><div class="line">// --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑</div><div class="line">pthread_mutex_unlock(&amp;mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。</p>
<p>wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。</p>
<p>###为什么要使用条件变量<br>介绍条件变量的文章非常多，但大多都对一个一个基本问题避而不谈:“为什么要用条件变量？它仅仅是控制了线程的执行顺序，用信号量或者互斥锁能不能模拟出类似效果？”<br>网上的相关资料比较少，我简单说一下个人看法。信号量可以一定程度上替代 condition，但是互斥锁不行。在以上给出的生产者-消费者模式的代码中，pthread_cond_wait<br>方法的本质是锁的转移，消费者放弃锁，然后生产者获得锁，同理，pthread_cond_signal<br>则是一个锁从生产者到消费者转移的过程。<br>如果使用互斥锁，我们需要把代码改成这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void consumer () &#123; // 消费者</div><div class="line">pthread_mutex_lock(&amp;mutex);</div><div class="line">while (data == NULL) &#123;</div><div class="line">pthread_mutex_unlock(&amp;mutex);</div><div class="line">pthread_mutex_lock(&amp;another_lock)  // 相当于 wait 另一个互斥锁</div><div class="line">pthread_mutex_lock(&amp;mutex);</div><div class="line">&#125;</div><div class="line">pthread_mutex_unlock(&amp;mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做存在的问题在于，在等待 another_lock 之前， 生产者有可能先执行代码， 从而释放了 another_lock。也就是说，我们无法保证释放锁和等待另一个锁这两个操作是原子性的，也就无法保证“先等待、后释放 another_lock” 这个顺序。<br>用信号量则不存在这个问题，因为信号量的等待和唤醒并不需要满足先后顺序，信号量只表示有多少个资源可用，因此不存在上述问题。然而与pthread_cond_wait<br>保证的原子性锁转移相比，使用信号量似乎存在一定风险(暂时没有查到非原子性操作有何不妥)。<br>不过，使用 condition 有一个好处，我们可以调用pthread_cond_broadcast<br>方法通知所有等待中的消费者，这是使用信号量无法实现的。</p>
<p>#七、@synchronized</p>
<p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>
<p>我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。</p>
<p>#综合上述分析与讨论，总结有以下几点原则：<br>1、总的来看，推荐pthread_mutex作为实际项目的首选方案；<br>2、对于耗时较大又易冲突的读操作，可以使用读写锁代替pthread_mutex；<br>3、如果确认仅有set/get的访问操作，可以选用原子操作属性；<br>4、对于性能要求苛刻，可以考虑使用OSSpinLock，需要确保加锁片段的耗时足够小；<br>5、条件锁基本上使用面向对象的NSCondition和NSConditionLock即可；<br>6、@synchronized则适用于低频场景如初始化或者紧急修复使用；</p>
<p>#八、锁的第二层含义</p>
<p>一个简单的问题：在存在编译乱序与指令执行乱序的情况下，怎么保证锁所保护的代码片段，不会被提前到加锁之前，或者是放锁之后执行？如果编译器将锁保护下的代码，通过编译优化，放到了加锁之前运行？又如果CPU在执行指令时，将锁保护下的汇编代码，延迟到了放锁之后执行？如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-a937659e764d4cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5FF8FB43-6327-471D-81E4-AD0DB4CE3C1E.png"></p>
<p>如上所示，如果编译器做了它不该做的优化，或者CPU做了其不该做的乱序，那么spinlock保护下的代码片段，同一时刻，一定只有一个线程能够执行的假设被打破了。此时，虽然spinlock仍旧只能有一个线程持有，但是spinlock保护下的代码，被提到了spinlock保护之外执行，spinlock哪怕功能再强大，也不能保护锁之外的代码，提取到spinlock锁之外的代码，能够并发执行。</p>
<p>但是上面的测试说明，spinlock保护下的global_count++操作，在多线程下能够正确执行。也就说明，无论是编译器，还是CPU，并没有不合时宜的做上面的这些优化。而分析其原因，刚好引出了锁（Spinlock、Mutex、RWLock等）的第二层意义：Lock Acquire和Unlock Release。</p>
<p>什么是Lock Acquire，Unlock Release又意味着什么？在此之前，需要先看看什么是Acquire和Release。Acquire和Release语义（Semantics）是程序语言和CPU内存模型（Memory Model）中的一个概念。以下，是截取自Preshing博客《Acquire and Release Semantics》一文中，对Acquire与Release Semantics的定义：</p>
<p>Acquire semantics is a property which can only apply to operations which read from shared memory, whether they are read-modify-write operations or plain loads. The operation is then considered a read-acquire. Acquire semantics prevent memory reordering of the read-acquire with any read or write operation which follows it in program order. （注：Acquire语义是一个作用于内存读操作上的特性，此内存读操作即被视为read-acquire。Acquire语义禁止read-acquire之后所有的内存读写操作，被提前到read-acquire操作之前进行。）</p>
<p>Release semantics is a property which can only apply to operations which write to shared memory, whether they are read-modify-write operations or plain stores. The operation is then considered a write-release. Release semantics prevent memory reordering of the write-release with any read or write operation which precedes it in program order.（注：Release语义作用于内存写操作之上的特性，此内存写操作即被视为write-release。Release语义禁止write-release之前所有的内存读写操作，被推迟到write-release操作之后进行。）</p>
<p>从Acquire与Release语义的定义可以看出，两个语义对编译器优化、CPU乱序分别做了一个限制条件：</p>
<p>Acquire语义限制了编译器优化、CPU乱序，不能将含有Acquire语义的操作之后的代码，提到含有Acquire语义的操作代码之前执行；<br>acquire sematics</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-439d7cd2ee56106c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7F568A62-4FA8-49F7-BE39-B2A5A974B6FA.png"></p>
<p>Release语义限制了编译器优化、CPU乱序，不能将含有Release语义的操作之前的代码，推迟到含有Release语义的操作代码之后执行；<br>release sematics</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-ea08b284da61d69e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![Uploading 420A1577-FB42-4092-886A-CACF333A662D_050837.png . . .]"></p>
<p>有了明确的Acquire和Release语义的定义，再回过头来看前面提到的锁的第二层含义：Lock Acquire和Unlock Release。加锁操作自带Acquire语义，解锁操作自带Release语义。将加锁、解锁的两个语义结合起来，就构成了以下的完整的锁的含义图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-bb64d7b9ab48ffd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="420A1577-FB42-4092-886A-CACF333A662D.png"><br>锁含义</p>
<p>spinlock，只有带有了Acquire和Release语义，才算是一个真正完整可用的锁——Acquire与Release语义间，构成了一个临界区。获取spinlock后的线程，可以大胆的运行全局变量的读写，而不必担心其他并发线程对于此变量的并发访问。</p>
<p>好消息是，pthread lib所提供的spinlock、mutex，其加锁操作都自带了acquire语义，解锁操作都自带了release语义。因此，哪怕我们在使用的过程中，不知道有这两个语义的存在，也能够正确的使用这些锁。但是，读者需要实现自己的spinlock、mutex（注：实际情况下，确实有这个必要，数据库系统如Oracle/PostgreSQL/InnoDB，都有自己实现的Spinlock、Mutex等），那么对于锁的了解，到这个层次，是必不可少的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[iOS]Instagram/IGListKit实践谈]]></title>
      <url>http://chenmingjia.github.io/2016/11/10/unitsquare/</url>
      <content type="html"><![CDATA[<p>#简单介绍<br>IGListKit是Instagram推出的新的 UICollectionView 框架，使用数据驱动，旨在创造一个更快更灵活的列表控件。<br>github地址：<a href="https://github.com/Instagram/IGListKit" target="_blank" rel="external">https://github.com/Instagram/IGListKit</a><br>这个全新的控件一出来，我就赶快投入实践了一把。</p>
<p>先谈一谈我对这个控件的结论:这个框架设计的非常好，完美符合高内聚、低耦合。IGListKit 是一个很典型的使用 Objective-C 开发的，但却是个偏向使用 Swift 语言开发者的一个 UI 组件库。<br>使用过程也面临了一些疑惑，先谈一下使用收获:<br><img src="http://upload-images.jianshu.io/upload_images/712028-81c9910e9b51abfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2289D6DE-F316-4E7C-BD50-0B63BF33EEA8.png"></p>
<ol>
<li>它的优势在于flexible，比起原来的 UICollectionView ，在使用上更加灵活，在数据驱动上做的更好。</li>
<li>这个框架在fast上体现的还不够，但不妨碍我们自己进行下一步优化。</li>
</ol>
<p>#先看看IGListKit的结构</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-1bbefcabe3005a04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C49DDFF9-DBF9-4450-B407-91B319BBB240.png"><br>在原来的UICollectionViewController里的写法，我们一定都会实现UICollectionDataSource和UICollectionViewDelegate。<br>不过在IGListKit的实战过程中，你会发现似乎不用在ViewController中实现相关协议，取而代之的是SectionController来实现对应的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class DemoSectionController: IGListSectionController, IGListSectionType&#123;</div><div class="line">var object: DemoItem?</div><div class="line">func numberOfItems() -&gt; Int &#123;</div><div class="line">return 1</div><div class="line">&#125;</div><div class="line">func sizeForItem(at index: Int) -&gt; CGSize &#123;</div><div class="line">return CGSize(width: collectionContext!.containerSize.width, height: 55)</div><div class="line">&#125;</div><div class="line">func cellForItem(at index: Int) -&gt; UICollectionViewCell &#123;</div><div class="line">let cell = collectionContext!.dequeueReusableCell(of: LabelCell.self, for: self, at: index) as! LabelCell</div><div class="line">cell.label.text = object?.name</div><div class="line">return cell</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里直接取了官方的Demo里的其中一个SectionController作为例子。其实 UICollectionDataSource 和 UICollectionViewDelegate 都交给了 Adapter 这个适配器中。我们来看一下 IGAdapter.m 文件中的源码:<br>当我们为适配器绑定collectionView时，调用如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)setCollectionView:(IGListCollectionView *)collectionView &#123;</div><div class="line">if (_collectionView != collectionView || _collectionView.dataSource != self) &#123;</div><div class="line">_collectionView = collectionView;</div><div class="line">_collectionView.dataSource = self;</div><div class="line"></div><div class="line">[self updateCollectionViewDelegate];</div><div class="line">[self updateAfterPublicSettingsChange];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中self是指适配器对象。<br>接着适配器作为实现数据源协议的对象，我们来看一下它是怎么联系SectionController群的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">IGListSectionController&lt;IGListSectionType&gt; *sectionController = [self.sectionMap sectionControllerForSection:indexPath.section];</div><div class="line">_isDequeuingCell = YES;</div><div class="line">UICollectionViewCell *cell = [sectionController cellForItemAtIndex:indexPath.item];</div><div class="line">_isDequeuingCell = NO;</div><div class="line">[self mapCell:cell toSectionController:sectionController];</div><div class="line"></div><div class="line">return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到adapter通过遍历自己的sectionController的map来达到UICollectionView的数据源在cellForItem如何选择对应的sectionController。<br>坦白说，这样做，给人一种全新的思路，而且以后就算自己实现其实也并不复杂，可以参考其设计。</p>
<p>#WorkRange能做的事<br>什么是WorkRange？还是用Github的官方介绍说的更快，更清楚。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-408eae202f33d764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1A21C24B-A787-4B4C-8FA4-746BE27B4791.png"><br>大体就是说，我们可以指定左右的Working区间，干一些准备工作。<br>官网写的不多，只说了我们可以干事，具体干啥事，在我的个人实践中，我对它使用的理解是这样的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/712028-3e47a6a8bccb28cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="84CE80C0-B909-4CF9-B43D-A1D4B52763ED.png"><br>更新数据源及预排版在ViewController进行，为Item设置layout属性。这样在SectionController中可以无需计算直接使用排版数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func updateItem(withItems items:Array&lt;CommentItem&gt;) &#123;</div><div class="line">/*</div><div class="line">假设我们在viewController中更新数据源，item为数据模型</div><div class="line">Items = [CommentItem(name: &quot;Mike&quot;, comment: &quot;&quot;),</div><div class="line">CommentItem(name: &quot;Chen&quot;, comment: &quot;&quot;),</div><div class="line">....]</div><div class="line">*/             </div><div class="line">commentGroup = CommentGroup(Items: Items)</div><div class="line"></div><div class="line">let queue = DispatchQueue(label: &quot;myBackgroundQueue&quot;)</div><div class="line">queue.async &#123;</div><div class="line">for item in Items &#123;</div><div class="line">let layout = CommentMainItemLayout(commentItem: item)</div><div class="line">item.layout = layout</div><div class="line">&#125;</div><div class="line">self.commentModels.append(self.commentGroup!)</div><div class="line"></div><div class="line">DispatchQueue.main.async &#123; [weak self] in</div><div class="line">self?.commentAdapter.performUpdates(animated: true, completion: nil)</div><div class="line">&#125;   </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而将预下载或者预渲染工作放在workRange中。<br><img src="http://upload-images.jianshu.io/upload_images/712028-cc4c4069276ec5ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="87F4E1DC-3664-48C9-9DBE-7E541D07DBEF.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func listAdapter(_ listAdapter: IGListAdapter, sectionControllerWillEnterWorkingRange sectionController: IGListSectionController) &#123;</div><div class="line">for  url: object.urls &#123;</div><div class="line">ImageCache.setImage(withUrl:url)     //如果需要预渲染，可自行设定</div><div class="line">&#125;      </div><div class="line">&#125;</div><div class="line"></div><div class="line">func listAdapter(_ listAdapter: IGListAdapter, sectionControllerDidExitWorkingRange sectionController: IGListSectionController) &#123;</div><div class="line">ImageCache.cancel()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#Display Delegate</p>
<p>我还没来得及用到Display Delegate，但我觉得它非常适合在显示文本的控件上使用异步绘制<br>我们先来看一看它的调用顺序</p>
<ol>
<li>func cellForItem(at index: Int) -&gt; UICollectionViewCell    </li>
<li>func listAdapterwillDisplay</li>
<li>func listAdapterdidEndDisplaying </li>
</ol>
<p>可以发现cellForItem在willDisplay前面，于是我会选择在cellForItem执行异步绘制。<br>在listAdapterdidEndDisplaying暂停异步绘制，最大程度上防止滑动速度过快，导致白白浪费去执行绘制任务。</p>
<p>#和想象不一样的数据驱动<br>当初看到github中官方给的图是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/712028-da92b9680abe5b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="09A72A4F-A716-4CAD-9BBE-5C4CA445F079.png"><br>我以为IGListKit里的数据驱动是类似双向绑定的结构，更新时不用手动显式的调用Update，可实际修改数据源模型，还是要显式调用<br> adapter.performUpdates(animated: true, completion: nil)<br>而这句代码对应的就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">Perform an update from the previous state of the data source. This is analagous to calling</div><div class="line">-[UICollectionView performBatchUpdates:completion:].</div><div class="line"></div><div class="line"></div><div class="line">open func performUpdates(animated: Bool, completion: IGListKit.IGListUpdaterCompletion? = nil)</div></pre></td></tr></table></figure></p>
<p>为什么称为Never Call呢？</p>
<p>#再来看一下Diff算法<br>简单来说这个算法就是计算tableView或者collectionView前后数据变化增删改移关系的一个算法，时间复杂度是O(n)，算是IGListKit的特色特点之一。<br>其实这个算法单独拿出来不只可以计算collectionView模型，稍加改造，也适用于其他模型或者文件的变化<br>使用的是Paul Heckel 的<a href="http://dl.acm.org/citation.cfm?id=359467&amp;dl=ACM&amp;coll=DL" target="_blank" rel="external">A technique for isolating differences between files</a> 的算法，这份paper是收费。<br>不过这并不妨碍我们直接看源码，我们可以看一下IGListDiff.mm文件,该算法使用C++来编写。<br>主要是通过hashtable和新旧的两个数组结构：<br><img src="http://upload-images.jianshu.io/upload_images/712028-71cfbf10af55361d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FB5A6940-3E6D-481A-9211-16127D3C767B.png"><br>用简单的例子来说，这里我模拟的是从假设原来的  1，2，4，1的旧数据模型到新的1，2，3，5的数据模型的变化过程，假想成Swift中代码，应该是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let oldModel = [</div><div class="line">Num(id: 1, name: &quot;1&quot;),</div><div class="line">Num(id: 2, name: &quot;2&quot;),</div><div class="line">Num(id: 3, name: &quot;4&quot;),</div><div class="line">Num(id: 4, name: &quot;1&quot;),</div><div class="line">]</div><div class="line">let newModel = [</div><div class="line">Num(id: 1, name: &quot;1&quot;),</div><div class="line">Num(id: 2, name: &quot;2&quot;),</div><div class="line">Num(id: 3, name: &quot;3&quot;),</div><div class="line">Num(id: 4, name: &quot;5&quot;),</div><div class="line">]</div><div class="line">let result = IGListDiffPaths(0, 0, from, to, .equality).forBatchUpdates()</div><div class="line">tableView.beginUpdates()</div><div class="line">tableView.deleteRows(at: result.deletes, with: .fade)</div><div class="line">tableView.insertRows(at: result.inserts, with: .fade)</div><div class="line">for move in result.moves &#123;</div><div class="line">tableView.moveRow(at: move.from, to: move.to)</div><div class="line">&#125;</div><div class="line">tableView.endUpdates()</div></pre></td></tr></table></figure></p>
<p>首先oldIndexs是一个栈的结构，过程是先遍历新数组，将数组里模型的id对应的hash值作为key，找到对应的Num成员对象（实际代码中为entry，可以理解为一种抽象）的oldIndexs栈存入NSNotFound。<br>再遍历旧数组，拿例子来说，就是将数组里模型的id  对应的hash值作为key，找到对应的Num成员对象里的oldIndexs栈增加旧数组的下标值。<br>如果是新增加的，那么在hashtable中key对应的value存入的Num成员对象就是notfound。<br>这样算法如图使用的数据结构（已简化，实际稍复杂些），可以绑定新旧数组的成员的对应关系，包括成员间的移动增加删除修改关系，对于像TableView或者CollectionView非常适合不过。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[译]使用幽灵类型的Measurements和Units ，第四部分]]></title>
      <url>http://chenmingjia.github.io/2016/10/18/unitsquare/</url>
      <content type="html"><![CDATA[<p>原文链接=<a href="https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/" target="_blank" rel="external">https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/</a><br>作者=Ole Begemann<br>译者=与狼同行</p>
<!--此处开始正文-->
<p>本系列其他文章：</p>
<p>(1) <a href="http://oleb.net/blog/2016/07/measurements-and-units/" target="_blank" rel="external">Measurements 和 Units 概览</a><br>(2) <a href="http://oleb.net/blog/2016/07/unitproduct/" target="_blank" rel="external">乘法和除法</a><br>(3) <a href="http://swift.gg/2016/09/29/unitsquare/" target="_blank" rel="external">内容提炼</a><br>(4) 幽灵类型(本文)</p>
<p>我之前撰写了关于标准库里新的度量值的短系列，此文是该系列的额外之作。虽然我很喜欢苹果的 API ，但我觉得探索同一问题的不同解决方案也很有意思。特别是这个问题，纯 Swift 设计是否能优于苹果的接口呢，因为苹果的接口考虑了 Objective-C 的<a href="https://lists.swift.org/pipermail/swift-corelibs-dev/Week-of-Mon-20160808/000864.html" target="_blank" rel="external">兼容性问题</a>。</p>
<a id="more"></a>
<h2 id="苹果的设计"><a href="#苹果的设计" class="headerlink" title="苹果的设计"></a>苹果的设计</h2><p>在苹果的 API 中，开发者主要使用的数据类型是<a href="https://developer.apple.com/reference/foundation/nsmeasurement" target="_blank" rel="external">度量值 <code>Measurement</code> 类型</a>，它包含一个浮点数  <code>value</code> 和用于测值的单位 <code>unit</code> ，并基于单位类型使用了泛型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Measurement&lt;UnitType: Unit&gt; &#123;</div><div class="line">let unit: UnitType</div><div class="line">var value: Double</div><div class="line">&#125;</div><div class="line"></div><div class="line">let length = Measurement(value: 5， unit: UnitLength.meters)</div><div class="line">// 长度表现为一个 Measurement&lt;UnitLength&gt;</div></pre></td></tr></table></figure>
<p>Measurement 被视为<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md" target="_blank" rel="external">值类型</a>——它在 Objective-C 中是类，在 Swift 中是结构体。<br>在单位族（Unit Family）中，比如说长度或时长，被建模为类层次结构中的类型:  <a href="https://developer.apple.com/reference/foundation/nsunit" target="_blank" rel="external">Unit</a> &gt; <a href="https://developer.apple.com/reference/foundation/nsdimension" target="_blank" rel="external">Dimension</a> &gt; <a href="https://developer.apple.com/reference/foundation/nsunitlength" target="_blank" rel="external">UnitLength</a> 、 <a href="https://developer.apple.com/reference/foundation/nsunitduration" target="_blank" rel="external">UnitDuration</a>等等。具体的类型如米、千克，分别是它们单位族类的实例。每一个单位都是由单位的符号（如「kg」）和一个 <a href="https://developer.apple.com/reference/foundation/unitconverter" target="_blank" rel="external">单元转换</a>对象组成，该对象通过编码指令来使单位转化为该单位族的基本单位。</p>
<h2 id="幽灵类型"><a href="#幽灵类型" class="headerlink" title="幽灵类型"></a>幽灵类型</h2><p>如果我们将具体的单位视为一个类型而不是实例呢？假设有一些类型名为米（Meters）、千米（Kilometers），或者英里（Miles），我们可以设计一个泛型的 <code>Measurement</code> 类型，它只有一个存储属性来存放量值，该量值的单位可以被完整编码在自身类型中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct MyMeasurement&lt;UnitType: MyUnit&gt; &#123;</div><div class="line">var value: Double</div><div class="line"></div><div class="line">init(_ value: Double) &#123;</div><div class="line">self.value = value</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let length = MyMeasurement&lt;Meters&gt;(5)</div><div class="line">// length is a MyMeasurement&lt;Meters&gt;</div></pre></td></tr></table></figure></p>
<p>现在我们再次审视两种方式的不同之处，苹果的设计是让单位族 <code>length</code>作为 <code>Measurement</code> 的参数，让具体的单位 米 作为该值的一部分。而我的设计是让具体的单位 米 成为泛型参数。<br><code>MyMeasurement</code> 也能被称为<a href="https://wiki.haskell.org/Phantom_type" target="_blank" rel="external">幽灵类型</a>，因为泛型参数 UnitType 没有在类型声明中出现。它的用途仅仅是用于相互区分类似 <code>MyMeasurement &lt;Meters&gt;</code> 和 <code>MyMeasurement &lt;Kilometers&gt;</code> 这样的类型，这样它们就无法互相替换。<br>我们之后将看看这样设计是否真的有用，因为你可能会争辩，用米的度量值应当能与用千米的度量值互相转换。想了解更多关于 Swift 中幽灵类型的例子，可以看 <a href="https://www.objc.io/blog/2014/12/29/functional-snippet-13-phantom-types/" target="_blank" rel="external">objc.org</a> 的文章或 <a href="https://realm.io/news/swift-summit-johannes-weiss-the-type-system-is-your-friend/" target="_blank" rel="external">Johannes Weiß</a> 的谈话。Swift标准库也在使用幽灵类型，例如 <a href="https://developer.apple.com/reference/swift/unsafepointer" target="_blank" rel="external">UnsafePointer <memory></memory></a> 。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我的方法最明显的好处是比使用度量值数据类型在大小上要小 50 % ，因为对单位实例的引用不是必要的。（单位实例自身是被所有那个单位的 Measurement 类所共用的，例如 5 米 和 10 米 两个度量值引用的是同一个单位实例。）但大小尺寸上的节省优势会被潜在更大的代码量所抵消，因为编译器会为泛型类型和使用该类型的函数产生更多的特化。</p>
<p>由于 Unit 在苹果的 API 中为引用类型，将测量值传给函数也会带来 retain 和 release 的开销。这两个因素对一个传统 App 来说都不是很重要，我也没有展开进一步的研究，在探索这些想法的时候，它们对我来说无关紧要。</p>
<h2 id="具体的设计"><a href="#具体的设计" class="headerlink" title="具体的设计"></a>具体的设计</h2><p>我们现在具体说一下如何在这个系统中定义单位，所有的单位都被封装到不同的单位族中，比如长度、温度、时长。我们开始为单位族定义一个协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// 表现为一种物理数值 或者 可以认为是 “ 单位之族 ”</div><div class="line">/// 例如: 长度， 温度， 速率.</div><div class="line">protocol UnitFamily &#123;</div><div class="line">associatedtype BaseUnit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如苹果API中，每个单位族都会定义一个基础单位，它用于同一单位族的不同类型间的相互转换，例如长度单位族的基础单位是米。我们在 <code>UnitFamily</code> 协议中，把该基础单位定义为一个关联类型，这会有一个好处，基础单位会在这个类型系统中被编码，在 Foundation 库中，基础单位必须被单独记录以使得其他人用自定义的单位来扩展这个系统。</p>
<p>下一步是定义 <code>MyUnit</code> 协议以塑造具体的单位，这些单位在苹果的设计中会被定义为单位族类型的一个实例。（这里我使用 My 作为前缀来避免和苹果类型的命名冲突）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/// 表现为度量值的单位</div><div class="line">/// 例如: 米， 公里， 英里， 秒， 小时， 摄氏度.</div><div class="line">protocol MyUnit &#123;</div><div class="line">associatedtype Family: UnitFamily</div><div class="line"></div><div class="line">static var symbol: String &#123; get &#125;</div><div class="line">static var converter: UnitConverter &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单位通过关联类型的方式来进行声明其所属的单位族。用静态属性来保存它的符号（比如米的符号是 m ，磅的符号是 lbs ）和它的单位转化器，转化器描述了如何将该单位转化为该族的基础单位。假如说长度单位族的基础单位是米，那么公里单位的转化器应该就是 <code>UnitConverterLinear(coefficient: 1000)</code>。基础单位自身的转化器系数应该为1。我这里从 Foundation 库中借用了<a href="https://developer.apple.com/reference/foundation/unitconverter" target="_blank" rel="external">UnitConverter</a> 类型。 Foundation 库将没有维度单位的 Unit 和有维度单位的 Dimension 进行了区分。简单起见，我们就不做这些事了，我们所有的单位都是有维度的。<br>基础单位也必须是一个单位类型，这样想当然没错，理想来说在 UnitFamily 协议中的 BaseUnit 应当有一个对应的基础单位约束，那就是 MyUnit 。不过遗憾的是，这样会使得两个协议之间产生循环引用，这样在Swift中肯定是不被许可的。话虽如此说，但即便没有约束，一切也能工作顺利。</p>
<h2 id="遵守协议"><a href="#遵守协议" class="headerlink" title="遵守协议"></a>遵守协议</h2><p>现在来为协议添加具体的实现。我这里展示一下长度、速度和时长的例子，每个都设置几个单位，再添加更多的单位和单位族也没什么意义。我选择用枚举来作为类型的结构，因为无例枚举不能被实例化，这对我们来说非常完美，因为我们只对类型感兴趣，而不是对类型的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">enum Length: UnitFamily &#123;</div><div class="line">typealias BaseUnit = Meters</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Meters: MyUnit &#123;</div><div class="line">typealias Family = Length</div><div class="line">static let symbol = &quot;m&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Kilometers: MyUnit &#123;</div><div class="line">typealias Family = Length</div><div class="line">static let symbol = &quot;km&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1000)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - Duration</div><div class="line">enum Duration: UnitFamily &#123;</div><div class="line">typealias BaseUnit = Seconds</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Seconds: MyUnit &#123;</div><div class="line">typealias Family = Duration</div><div class="line">static let symbol = &quot;s&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Minutes: MyUnit &#123;</div><div class="line">typealias Family = Duration</div><div class="line">static let symbol = &quot;min&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 60)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Hours: MyUnit &#123;</div><div class="line">typealias Family = Duration</div><div class="line">static let symbol = &quot;hr&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 3600)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - Speed</div><div class="line">enum Speed: UnitFamily &#123;</div><div class="line">typealias BaseUnit = MetersPerSecond</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum MetersPerSecond: MyUnit &#123;</div><div class="line">typealias Family = Speed</div><div class="line">static let symbol = &quot;m/s&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum KilometersPerHour: MyUnit &#123;</div><div class="line">typealias Family = Speed</div><div class="line">static let symbol = &quot;km/h&quot;</div><div class="line">static let converter: UnitConverter = UnitConverterLinear(coefficient: 1.0/3.6)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="转换度量值"><a href="#转换度量值" class="headerlink" title="转换度量值"></a>转换度量值</h2><p>现在我们已经可以用不同的单位来表示度量值，接着我们需要让它们相互转换。<code>converted(to:)</code> 方法传入一个目标单位类型的参数并通过单位转换器返回那个单位新的度量值。注意这句约束<code>TargetUnit.Family == UnitType.Family</code>，它限制了转换只能适用于同单位族，编译器不会让你把<code>Meters</code>转换为<code>Seconds</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">extension MyMeasurement &#123;</div><div class="line">/// Converts `self` to a measurement that has another unit of the same family.</div><div class="line">func converted&lt;TargetUnit&gt;(to target: TargetUnit.Type) -&gt; MyMeasurement&lt;TargetUnit&gt;</div><div class="line">where TargetUnit: MyUnit， TargetUnit.Family == UnitType.Family</div><div class="line">&#123;</div><div class="line">let valueInBaseUnit = UnitType.converter.baseUnitValue(fromValue: value)</div><div class="line">let valueInTargetUnit = TargetUnit.converter.value(fromBaseUnitValue: valueInBaseUnit)</div><div class="line">return MyMeasurement&lt;TargetUnit&gt;(valueInTargetUnit)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来为 <code>MyMeasurement</code> 添加一些方便的功能，遵守<code>CustomStringConvertible</code>是一个输出调试的良好方案，并通过遵守 <code>ExpressibleByIntegerLiteral</code> 和 <code>ExpressibleByFloatLiteral</code> 协议使得通过字面量创建新的度量值变得更加轻松愉快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">extension MyMeasurement: CustomStringConvertible &#123;</div><div class="line">var description: String &#123;</div><div class="line">return &quot;\(value) \(UnitType.symbol)&quot;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension MyMeasurement: ExpressibleByIntegerLiteral &#123;</div><div class="line">init(integerLiteral value: IntegerLiteralType) &#123;</div><div class="line">self.value = Double(value)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension MyMeasurement: ExpressibleByFloatLiteral &#123;</div><div class="line">init(floatLiteral value: FloatLiteralType) &#123;</div><div class="line">self.value = value</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>现在我们开始创造一些度量值并把它们转换为其他单位，应用字面量的语法来表达对象创建非常不错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let fiveMeters: MyMeasurement&lt;Meters&gt; = 5</div><div class="line">// → 5.0 m</div><div class="line">let threeKilometers: MyMeasurement&lt;Kilometers&gt; = 3</div><div class="line">// → 3.0 km</div><div class="line">threeKilometers.converted(to: Meters.self)</div><div class="line">// → 3000.0 m</div><div class="line">threeKilometers.converted(to: Seconds.self)</div><div class="line">// error: &apos;Family&apos; (aka &apos;Length&apos;) is not convertible to &apos;Family&apos; (aka &apos;Duration&apos;) (as expected)</div></pre></td></tr></table></figure>
<p>我们再来看看把度量值作为函数参数会怎么样？看一下这个假想的<code>delay</code>函数，它以时长和一个闭包作为参数，并在具体时长后执行闭包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func delay(after duration: MyMeasurement&lt;Seconds&gt;， block: () -&gt; ()) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数需要以秒为单位的度量值，如果你传入了毫秒作为参数，你必须负责转化值。以 <code>TimeInterval</code> 作为参数可以具有类型安全的优势，编译器不会允许你传入 <code>MyMeasurement&lt;Milliseconds&gt;</code> 作参数，但这样做会比我们使用 <code>Measurement&lt;UnitDuration&gt;</code> 要大大降低灵活性，使用后者将会允许我们传入任意的时长单位。</p>
<p>我们通过基于单位类型将函数泛型化实现它(并且附上约束，它的单位族必须为时长)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func delay&lt;Time&gt;(after duration: MyMeasurement&lt;Time&gt;， block: () -&gt; ())</div><div class="line">where Time: MyUnit， Time.Family == Duration</div><div class="line">&#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法会有用，但会大大降低函数签名的可读性，即便是在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md" target="_blank" rel="external"> Where 子句的位置被转移</a>之后。</p>
<p>但就这一条理由来说，苹果将单位设为实例而不是类型的做法可能更为实用，更有意义。毕竟，米和公里只是同一东西的不同说法而已。但探索这个问题并不是很有意义，我们还是先继续。</p>
<h2 id="加法和标量乘法"><a href="#加法和标量乘法" class="headerlink" title="加法和标量乘法"></a>加法和标量乘法</h2><p>有时候我们需要把同样单位族的两个度量值作加法，即便他们有不同单位。通过使用泛型来重载 <code>+</code> 运算符方法就会容易，并且在习惯上我们会把右边的值转化为左边值得单位，并返回基于那个单位的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func + &lt;Unit1， Unit2&gt; (lhs: MyMeasurement&lt;Unit1&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Unit1&gt;</div><div class="line">where Unit1: MyUnit， Unit2: MyUnit， Unit1.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let rhsConverted = rhs.converted(to: Unit1.self)</div><div class="line">return MyMeasurement(lhs.value + rhsConverted.value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fiveMeters + threeKilometers</div><div class="line">// → 3005.0 m</div><div class="line">threeKilometers + fiveMeters</div><div class="line">// → 3.005 km</div></pre></td></tr></table></figure>
<p>我们再来注意一下这个约束 <code>Unit1.Family == Unit2.Family</code> ，它防止秒和米相加。</p>
<p>标量乘法就更容易实现了，因为没有单位转换参与。我们简单的把值相乘并创造一个新的度量值，两个重载方法被用于 <code>a * b</code> 和 <code>b * a</code> 两种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func * &lt;UnitType&gt; (measurement: MyMeasurement&lt;UnitType&gt;， scalar: Double) -&gt; MyMeasurement&lt;UnitType&gt; &#123;</div><div class="line">var result = measurement</div><div class="line">result.value *= scalar</div><div class="line">return result</div><div class="line">&#125;</div><div class="line"></div><div class="line">func * &lt;UnitType&gt; (scalar: Double， measurement: MyMeasurement&lt;UnitType&gt;) -&gt; MyMeasurement&lt;UnitType&gt; &#123;</div><div class="line">return measurement * scalar</div><div class="line">&#125;</div><div class="line"></div><div class="line">threeKilometers * 2</div><div class="line">// → 6.0 km</div><div class="line">let twoSeconds: MyMeasurement&lt;Seconds&gt; = 2</div><div class="line">60 * twoSeconds</div><div class="line">// → 120.0 s</div></pre></td></tr></table></figure>
<p>如果你记得这个系列的<a href="https://oleb.net/blog/2016/07/unitproduct/" target="_blank" rel="external">第二部分</a>，我最初的目的是想让单位之间可以被设计得相互依赖，例如  速度 = 路程 / 时间  或者 能量 = 功率 × 时间 。为了做到这些，我要介绍一个协议叫做 <code>UnitProduct</code>，通过遵守该协议和命名作为关联类型的因子，这样单位族可以表示其因子。</p>
<p>我们又做同样的事，但这次展示不同单位的关系而不是单位族。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// Describes this relation between units:</div><div class="line">/// Product = Factor1 * Factor2</div><div class="line">protocol Product: MyUnit &#123;</div><div class="line">associatedtype Factor1: MyUnit</div><div class="line">associatedtype Factor2: MyUnit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下这样一个简单的协议足以描述乘法性和除法性关系，因为 <code>a = b × c</code> 等价于 <code>b = a / c</code>。选择结果是随意的，这样无论怎么选都会让这个关系看上去不自然。举例来说，假如我们想表示 速度 = 路程 / 时间，我们就得也把它重写为 路程 = 速度 × 时间 。<br>下一步来实现实际计算，即重载作用于遵守协议的类型的乘法和除法运算符方法。我们需要四个变量：<br><code>a = b × c</code><br>泛型约束让它看起来更加复杂了，对于任意遵守 <code>Product</code> 协议的 <code>Result</code> 类型，这个重载方法定义两个度量值的乘法，这两个度量值的单位 <code>Unit1</code> 和 <code>Unit2</code> 有着和 <code>Result</code>的 <code>Result.Factor1</code>和 <code>Result.Factor2</code>同样的单位族。而结果是通过将度量值各自转化为 <code>Result.Factor1</code> 和 <code>Result.Factor2</code> ，然后相乘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func * &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Unit1&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Result&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let left = lhs.converted(to: Result.Factor1.self)</div><div class="line">let right = rhs.converted(to: Result.Factor2.self)</div><div class="line">return MyMeasurement(left.value * right.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>a = c × b</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func * &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Unit2&gt;， rhs: MyMeasurement&lt;Unit1&gt;) -&gt; MyMeasurement&lt;Result&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">return rhs * lhs</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这和先前的函数不完全类似，它将 lhs和 rhs 置换了。实现方式仅仅是转发给其他重载方法。</p>
<p><code>b = a / c   and  c = a / b</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func / &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Result&gt;， rhs: MyMeasurement&lt;Unit2&gt;) -&gt; MyMeasurement&lt;Unit1&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let right = rhs.converted(to: Result.Factor2.self)</div><div class="line">return MyMeasurement(lhs.value / right.value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func / &lt;Unit1， Unit2， Result&gt; (lhs: MyMeasurement&lt;Result&gt;， rhs: MyMeasurement&lt;Unit1&gt;) -&gt; MyMeasurement&lt;Unit2&gt;</div><div class="line">where Result: Product， Result.Factor1.Family == Unit1.Family， Result.Factor2.Family == Unit2.Family</div><div class="line">&#123;</div><div class="line">let right = rhs.converted(to: Result.Factor1.self)</div><div class="line">return MyMeasurement(lhs.value / right.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的方式，不过泛型参数的位置发生了变化。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>现在它终于可以表示关系 路程 = 速度 × 时间（即 速度 = 路程 / 时间）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extension Meters: Product &#123;</div><div class="line">typealias Factor1 = MetersPerSecond</div><div class="line">typealias Factor2 = Seconds</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可以这样用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let tenMeters: MyMeasurement&lt;Meters&gt; = 10</div><div class="line">let fourSeconds: MyMeasurement&lt;Seconds&gt; = 4</div><div class="line">let speed: MyMeasurement&lt;MetersPerSecond&gt; = tenMeters / fourSeconds</div><div class="line">// → 2.5 m/s</div><div class="line"></div><div class="line">let thirtyKilometersPerHour: MyMeasurement&lt;KilometersPerHour&gt; = 30</div><div class="line">let twoHours: MyMeasurement&lt;Hours&gt; = 2</div><div class="line">let tripLength: MyMeasurement&lt;Meters&gt; = thirtyKilometersPerHour * twoHours</div><div class="line">// → 60000.0 m</div><div class="line">tripLength.converted(to: Kilometers.self)</div><div class="line">// → 60.0 km</div></pre></td></tr></table></figure>
<p>它的工作效果不错，但是有两个明显的缺点。第一个是目前的编译器无法推断出自动计算的返回类型，我不知道是否今后的编译器可以解决这个问题，也许我可以通过在函数中设置更好的泛型约束的方式提供一些帮助，但是尝试之后，依然没能解决问题。<br>第二点是参数的单位需要有正确的单位族，返回类型的单位会被使用 <code>Product</code> 协议的具体单位所限制。因此类似 <code>let tripLength: MyMeasurement&lt;Kilometers&gt; = ...</code> 并不会起作用，你必须先提供以米形式的结果，然后再把它转换。这是一个非常大的限制。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>忽略这个设计的缺陷（确实存在），你得注意不止一行可执行代码需要为类型系统增加数学关系！仅仅通过添加协议一致（即定义两个关联类型），我们就可以从字面上把任务 1 meter = 1 m/s × 1 s 添加给编译器的“真理”池。但如果你要添加其他数学关系（比如1 J = 1 W × 1 s），那么我们就必须再添加一个协议一致。<br>我觉得这种写法非常吸引我。但尽管如此，我不认为这个基于幽灵类型的 API 优于苹果基础库中的 API，基于单位族而不是单位的度量值其实只会更加有意义。</p>
]]></content>
    </entry>
    
  
  
</search>
